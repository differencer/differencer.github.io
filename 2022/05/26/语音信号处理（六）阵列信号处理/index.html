<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>语音信号处理（六） 阵列信号处理 | tのblog</title><meta name="author" content="taotaozi"><meta name="copyright" content="taotaozi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、阵列信号处理的基本概念阵列信号处理大致可以分为两种用途：一个是滤波一个是估计。这两个用途其实在单通道的信号处理也有相似的概念，只不过这种滤波和估计被拓展到空间域之上。 1.1、阵列信号模型考虑一个三维立体模型，里面有n个任意位置摆放的阵元，且阵元都是全向阵元。声源从a方向入射。如图所示，模型可以提取两种信息：  1、N个权阵元的摆放位置 2、声源入射方向在这样两层信息的加持下，就可以写阵列输入">
<meta property="og:type" content="article">
<meta property="og:title" content="语音信号处理（六） 阵列信号处理">
<meta property="og:url" content="https://differencer.github.io/2022/05/26/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%E9%98%B5%E5%88%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="tのblog">
<meta property="og:description" content="一、阵列信号处理的基本概念阵列信号处理大致可以分为两种用途：一个是滤波一个是估计。这两个用途其实在单通道的信号处理也有相似的概念，只不过这种滤波和估计被拓展到空间域之上。 1.1、阵列信号模型考虑一个三维立体模型，里面有n个任意位置摆放的阵元，且阵元都是全向阵元。声源从a方向入射。如图所示，模型可以提取两种信息：  1、N个权阵元的摆放位置 2、声源入射方向在这样两层信息的加持下，就可以写阵列输入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://differencer.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-05-26T07:11:36.000Z">
<meta property="article:modified_time" content="2023-04-06T10:42:13.555Z">
<meta property="article:author" content="taotaozi">
<meta property="article:tag" content="语音信号处理">
<meta property="article:tag" content="阵列信号处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://differencer.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://differencer.github.io/2022/05/26/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%E9%98%B5%E5%88%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '语音信号处理（六） 阵列信号处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-06 18:42:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> 关于主题</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://differencer.oss-cn-beijing.aliyuncs.com/img/cover(1).jpg.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="tのblog"><span class="site-name">tのblog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> 关于主题</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">语音信号处理（六） 阵列信号处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-26T07:11:36.000Z" title="发表于 2022-05-26 15:11:36">2022-05-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-06T10:42:13.555Z" title="更新于 2023-04-06 18:42:13">2023-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">语音信号处理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="语音信号处理（六） 阵列信号处理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、阵列信号处理的基本概念"><a href="#一、阵列信号处理的基本概念" class="headerlink" title="一、阵列信号处理的基本概念"></a>一、阵列信号处理的基本概念</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/26/OCAJvDKHnyYb8WP.png" alt=""><br>阵列信号处理大致可以分为两种用途：一个是滤波一个是估计。这两个用途其实在单通道的信号处理也有相似的概念，只不过这种滤波和估计被拓展到空间域之上。</p>
<h2 id="1-1、阵列信号模型"><a href="#1-1、阵列信号模型" class="headerlink" title="1.1、阵列信号模型"></a>1.1、阵列信号模型</h2><p>考虑一个三维立体模型，里面有n个任意位置摆放的阵元，且阵元都是全向阵元。声源从a方向入射。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/26/ESxFIT9MP15zCOZ.png" alt=""><br>如图所示，模型可以提取两种信息：</p>
<ul>
<li>1、N个权阵元的摆放位置</li>
<li>2、声源入射方向<br>在这样两层信息的加持下，就可以写阵列<strong>输入信号</strong>的表达形式：<script type="math/tex; mode=display">
\begin{gathered}
\mathbf{x}(n, \mathbf{p})=\left[\begin{array}{c}
x\left(n, \mathbf{p}_{0}\right) \\
x\left(n, \mathbf{p}_{1}\right) \\
\vdots \\
x\left(n, \mathbf{p}_{N-1}\right)
\end{array}\right] 
\end{gathered}</script></li>
</ul>
<p>这个接受信号的矩阵其实也包含着两层信息：</p>
<ul>
<li>由于每一个阵元接受的其实是同一个声源发出的信息，所以每一路信号包含着x(n)信号，也即是同源的</li>
<li>由于每一个阵元位置的不同，就会收到每一个阵元空间方位（空间坐标）$\mathbf{p}_i$的影响。</li>
</ul>
<p>阵列<strong>接收信号</strong>（时域）的矩阵表示：</p>
<script type="math/tex; mode=display">
y(n)=\sum_{m=-\infty}^{\infty} \mathbf{h}^{T}(n-m) \mathbf{x}(m, \mathbf{p})</script><p>阵列信号的频域表示</p>
<script type="math/tex; mode=display">
Y(\omega)=\mathbf{H}^{T}(\omega) \mathbf{X}(\omega)</script><p>考虑声音的平面波入射的情况（绝大部分情况下的阵元模型都满足这一假设），在这种情况下，阵元信号的差异就主要体现在时延上，时延由阵元坐标决定  ：</p>
<script type="math/tex; mode=display">
\mathbf{x}(n, \mathbf{p})=\left[\begin{array}{c}
x\left(n-\tau_{0}\right) \\
x\left(n-\tau_{1}\right) \\
\vdots \\
x\left(n-\tau_{N-1}\right)
\end{array}\right]</script><p>另外还需要一个对比的阵元:每一个阵元他与<strong>哪一个阵元</strong>相比他的时延为$\tau_i$?<br>假设有一个阵元位于坐标原点（其实可以没有这样一个阵元，只是假设有），其他，其他阵元的时延可以由下式决定</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tau_{i} &=\frac{\mathbf{a}^{T} \mathbf{p}_{i}}{c}, \quad i=0, \ldots, N-1 \\
\end{aligned}</script><p>其中$\boldsymbol{a}$为<strong>声源入射方向</strong>，$\theta$为声源入射方向与$z$轴的夹角，也叫<strong>俯仰角</strong>，$\phi$角为入射射线投影到x-y平面后于x轴正方向的夹角，也叫<strong>方位角</strong>。注意 入射方向 每个坐标前面都带有负号！</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{a} &=\left[\begin{array}{c}
-\sin \theta \cos \phi \\
-\sin \theta \sin \phi \\
-\cos \theta
\end{array}\right]
\end{aligned}</script><p>这样，原来的接收信号的频域表示就可以写为（因为时域的演示对应为频域的相移）</p>
<script type="math/tex; mode=display">
\mathbf{X}(\omega)=\left[\begin{array}{c}
e^{-j \omega \tau_{0}} \cdot X(\omega) \\
e^{-j \omega \tau_{1}} \cdot X(\omega) \\
\vdots \\
e^{-j \omega \tau_{N-1}} \cdot X(\omega)
\end{array}\right]=\left[\begin{array}{c}
e^{-j \omega \tau_{0}} \\
e^{-j \omega \tau_{1}} \\
\vdots \\
e^{-j \omega \tau_{N-1}}
\end{array}\right] X(\omega)</script><p>部分文献将 乘式左边的列向量 称为 <strong>方向向量</strong><br>将时延公式带入上式，那么输入信号的频域表示也可以写成：</p>
<script type="math/tex; mode=display">
\omega \tau_{i}=\omega \frac{\mathbf{a}^{T} \mathbf{p}_{i}}{c}=\left(\frac{\omega}{c} \mathbf{a}\right)^{T} \mathbf{p}_{i}=\mathbf{k}^{T} \mathbf{p}_{i}</script><script type="math/tex; mode=display">
\mathbf{X}(\omega)=\left[\begin{array}{c}
e^{-j \mathbf{k}^{T} \mathbf{p}_{0}} \\
e^{-j \mathbf{k}^{T} \mathbf{p}_{1}} \\
\vdots \\
e^{-j \mathbf{k}^{T} \mathbf{p}_{N-1}}
\end{array}\right] X(\omega)=\mathbf{v}_{\mathbf{k}}(\mathbf{k}) X(\omega)</script><p>其中$\mathbf{k}$也被称为<strong>波数向量</strong>，之所以这样叫，因为$\begin{aligned} \mathbf{k}= \frac{\omega}{c} \mathbf{a}=\frac{2\pi f}{c} \mathbf{a}= \frac{2\pi }{\lambda} \mathbf{a} \end{aligned}$,那么方向向量的相位就可以写为波数向量于方向向量的向量乘积。 这种写法得到的方向向量也叫“阵列流行矢量”，注意它其实和方向向量是一个东东。 从这<strong>阵列流形矢量</strong>的定义来看，他已经规定好了一个阵列模型的所有空间信息了：1、各个阵元的空间方位，2、声源到达方向<br>其中，这个$\frac{2\pi }{\lambda}$ 我们在大学物理下或者电磁场理论中见过，叫做波数.</p>
<blockquote>
<p>频率$\omega$的单位是rad/s，表示时间变化一秒，相位的变化量，描述波动随时间的变化，称为时间角频率;波数k的单位是rad/m，表示空间距离变化一米，相位的变化量，描述波动随空间的变化，称为空间角频率。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/27/ZVifGCJnxS38hRN.png" alt=""><br>转自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37417060/answer/1339220595">知乎</a></p>
</blockquote>
<h1 id="二、波束成形"><a href="#二、波束成形" class="headerlink" title="二、波束成形"></a>二、波束成形</h1><h2 id="2-1、波束形成的概念"><a href="#2-1、波束形成的概念" class="headerlink" title="2.1、波束形成的概念"></a>2.1、波束形成的概念</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/26/Btvk1M4pzZDCusG.png" alt=""><br>所谓波束成形就是 通过多 天线阵列相关性  特定方向的音源获得增益 ，而干扰方向没有改进或者增益为零（如图中上半部分 有三倍的增益，下面只有一杯增益 而且还被分散了），<br>如图这种形式叫做延迟求和波束形成，是一种最基本最简单的波束形成方式。将时延模块改成滤波器模块，将变成更为通用的 滤波求和波束形成。所谓研究波束形成就是研究这个滤波器是怎样设计的。</p>
<p>假设已经得到了阵列输入信号信号模型，将每一路输入信号加入一个时延，使得每一路信号在时间上“对齐”：</p>
<script type="math/tex; mode=display">
h_i(n)=\frac{1}{N}\delta(n+\tau_i)</script><p>则</p>
<script type="math/tex; mode=display">
y(n)=x(n)</script><p>这种处理方式称为延迟求和波束形成（delay-and-sum beamformer / conventional beamformer）；这种方案虽然不是最优的波数形成方案，但是好在稳定，现在一般的系统还可以见到这种形式的实现。</p>
<p>一个重要的问题是，我们需要一个描述<strong>阵列系统</strong>对于任意输入信号的响应函数：</p>
<script type="math/tex; mode=display">
Y(\omega)=\mathbf{H}^T(\omega)\mathbf{X}(\omega)=\mathbf{H}^T(\omega)\mathbf{v_k(k)}X(\omega)</script><p><strong>频率波数响应（frequency-wavenumber response</strong></p>
<script type="math/tex; mode=display">
\Upsilon(\omega, \mathbf{k})=\mathbf{H}^{T}(\omega) \mathbf{v}_{\mathbf{k}}(\mathbf{k})</script><p><strong>波束方向图( beam pattern )</strong><br>即频率-波数响应在球面 $k=2 \pi / \lambda$ 上的取值 :</p>
<script type="math/tex; mode=display">
B(\omega: \theta, \phi)=\left.\Upsilon(\omega, \mathbf{k})\right|_{\mathbf{k}=\frac{2 \pi}{\lambda} \mathbf{a}}</script><p>对于波束方向图，如果给定频 率 $\omega_{c}$ ，频率-波数响应可以简化为：</p>
<script type="math/tex; mode=display">
\Upsilon(\omega, \mathbf{k})=\mathbf{H}^{T}\left(\omega_{c}\right) \mathbf{v}_{\mathbf{k}}(\mathbf{k})=\mathbf{w}^{H} \mathbf{v}_{\mathbf{k}}(\mathbf{k})=\left[\begin{array}{llll}
w_{0}^{*} & w_{1}^{*} & \ldots & w_{N-1}^{*}
\end{array}\right] \mathbf{v}_{\mathbf{k}}(\mathbf{k})</script><h2 id="2-2、举例，以均匀线性阵列（ULA）为例"><a href="#2-2、举例，以均匀线性阵列（ULA）为例" class="headerlink" title="2.2、举例，以均匀线性阵列（ULA）为例"></a>2.2、举例，以均匀线性阵列（ULA）为例</h2><p>Uniform Linear Array</p>
<p>假设阵列的排列方向位于$z$轴之上，如图；<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/27/tRpni21eOUAWoZx.png" alt=""><br>记为每个阵元的坐标为</p>
<script type="math/tex; mode=display">
p_{z_i}=(i-\frac{N-1}{2})d,i=0,1,……,N-1\\
p_{x_i}=p_{y_i}=0</script><p>$d$为阵元之间的距离。那么现在已经得到了阵列各个阵元的三维坐标向量了，将他带入阵列流形矢量当中，可以得到</p>
<script type="math/tex; mode=display">
\mathbf{v}_{\mathbf{k}}(k_z)=[e^{-j(0-\frac{N-1}{2})k_z d}, e^{-j(1-\frac{N-1}{2})k_z d},……,e^{-j(N-1-\frac{N-1}{2})k_z d} ] ^T \\
k_z=-\frac{2\pi}{\lambda}\cos(\theta)</script><p>显然，ULA的频率-波数响应可以表示为：</p>
<script type="math/tex; mode=display">
\Upsilon\left(\omega, k_{z}\right)=\mathbf{w}^{H} \mathbf{v}_{\mathbf{k}}\left(k_{z}\right)=\sum_{i=0}^{N-1} w_{i}^{*} e^{-j\left(i-\frac{N-1}{2}\right) k_{z} d}</script><p>相应的beam pattern可以表示为：</p>
<script type="math/tex; mode=display">
B_{\theta}(\theta)=\mathbf{w}^{H} \mathbf{v}_{\theta}(\theta)=e^{-j\left(\frac{N-1}{2}\right) \frac{2 \pi d}{\lambda} \cos \theta} \sum_{i=0}^{N-1} w_{i}^{*} e^{j i \frac{2 \pi d}{\lambda} \cos \theta}, \quad 0 \leq \theta \leq \pi</script><p>显然，该阵列的波数方向图只由俯仰角 $\theta$ 决定。</p>
<p>这个式也可以写成以下三种等价形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&B_{\theta}(\theta)=\mathbf{w}^{H} \mathbf{v}_{\theta}(\theta)=e^{-j\left(\frac{N-1}{2}\right) \frac{2 \pi d}{\lambda} \cos \theta} \sum_{i=0}^{N-1} w_{i}^{*} e^{j i \frac{2 \pi d}{\lambda} \cos \theta}, \quad 0 \leq \theta \leq \pi\\
& let \quad u=\cos \theta\\
&B_{u}(u)=\mathbf{w}^{H} \mathbf{v}_{u}(u)=e^{-j\left(\frac{N-1}{2}\right) \frac{2 \pi d}{\lambda} u} \sum_{i=0}^{N-1} w_{i}^{*} e^{j i \frac{2 \pi d}{\lambda} u}, \quad-1 \leq u \leq 1\\
& let \quad \psi=\frac{2 \pi d}{\lambda} u\\
&B_{\psi}(\psi)=\mathbf{w}^{H} \mathbf{v}_{\psi}(\psi)=e^{-j\left(\frac{N-1}{2}\right) \psi} \sum_{i=0}^{N-1} w_{i}^{*} e^{j i \psi}, \quad-\frac{2 \pi d}{\lambda} \leq \psi \leq \frac{2 \pi d}{\lambda}
\end{aligned}</script><p>经计算可以得到这样的 波束方向图。可以明显看到，俯仰角为$90^o$时（左边对应 $\pi/2$）阵列增益最大，这个方向也叫做主波束方向<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/27/wS94TsojnXc68Jt.png" alt=""></p>
<h2 id="2-3、主波束调向-beam-steering"><a href="#2-3、主波束调向-beam-steering" class="headerlink" title="2.3、主波束调向(beam  steering)"></a>2.3、主波束调向(beam  steering)</h2><p>如果在实际项目当中需要改变主波束的方向时，就需要调整<strong>频率-波数响应函数</strong>。</p>
<script type="math/tex; mode=display">
\begin{gathered}
\Upsilon\left(\omega, \mathbf{k}-\mathbf{k}_{T}\right) \leftarrow \Upsilon(\omega, \mathbf{k}) 
\end{gathered}</script><p>这样波数的指向就变成了$\mathbf{k}_{T}$对应的方向，这个”改写”的操作其实是作用在阵列流形矢量当中的。如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
{\left[\begin{array}{c}
e^{-j\left(\mathbf{k}-\mathbf{k}_{T}\right)^{T} \mathbf{p}_{0}} \\
e^{-j\left(\mathbf{k}-\mathbf{k}_{T}\right)^{T} \mathbf{p}_{1}} \\
\vdots \\
e^{-j\left(\mathbf{k}-\mathbf{k}_{T}\right)^{T} \mathbf{p}_{N-1}}
\end{array}\right] \leftarrow\left[\begin{array}{c}
e^{-j \mathbf{k}^{T} \mathbf{p}_{0}} \\
e^{-j \mathbf{k}^{T} \mathbf{p}_{1}} \\
\vdots \\
e^{-j \mathbf{k}^{T} \mathbf{p}_{N-1}}
\end{array}\right]} \\
\end{gathered}</script><p>改写之后对于对于整个系统的修正可以等价到系统的权值向量当中，就是将 下列的列向量点乘 原来的权值向量。</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathbf{w}_{T} \leftarrow\left[\begin{array}{c}
e^{j \mathbf{k}_{T}^{T} \mathbf{p}_{0}} \\
e^{j \mathbf{k}_{T}^{T} \mathbf{p}_{1}} \\
\vdots \\
e^{j \mathbf{k}_{T}^{T} \mathbf{p}_{N-1}}
\end{array}\right] \odot \mathbf{w}
\end{gathered}</script><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/rZHULRQDBV4PAX9.png" alt=""></p>
<p>对于上述调向 有一个重要的问题，<br>1、$\mathbf{k}_{T}$怎么求？</p>
<h2 id="2-4、方向图合成"><a href="#2-4、方向图合成" class="headerlink" title="2.4、方向图合成"></a>2.4、方向图合成</h2><p>频率-波数响应与权重向量之间的傅里叶变换关系？</p>
<script type="math/tex; mode=display">
B_{\psi}(\psi)=\mathbf{w}^{H} \mathbf{v}_{\psi}(\psi)=e^{-j\left(\frac{N-1}{2}\right) \psi} \sum_{i=0}^{N-1} w_{i}^{*} e^{j i \psi}, \quad-\frac{2 \pi d}{\lambda} \leq \psi \leq \frac{2 \pi d}{\lambda}\\
=e^{-j\left(\frac{N-1}{2}\right) \psi} \left(\sum_{i=0}^{N-1} w_{i} e^{-j i \psi}\right)</script><p>所以，我们可以利用时频分析的方法，修正线性阵列波束方向图，尽量<strong>减小旁瓣</strong>，保持<strong>最小的主瓣展宽程度</strong>——谱加权方法。</p>
<p>加权函数多为实对称函数，为了表述方便，定义：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\tilde{\imath}=\left(i-\frac{N-1}{2}\right), \quad & i=0,1, \ldots, N-1 \\
\tilde{\imath} &=-\frac{N-1}{2}, \ldots, \frac{N-1}{2}
\end{aligned}</script><p>可以利用fir滤波器中的一些窗函数对权值向量进行加权。但注意需要将主瓣的能量增益归一化到0dB才能更好的对比。</p>
<h3 id="cosine-加权"><a href="#cosine-加权" class="headerlink" title="cosine 加权"></a>cosine 加权</h3><script type="math/tex; mode=display">
w_{\tilde{\imath}}=\sin \left(\frac{\pi}{2N}\right)\cos\left(\pi \frac{\tilde{\imath}}{N}\right)</script><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/8fZRToqdipsj4aE.png" alt=""><br>可以看到 经过加权之后，旁瓣有着明显的抑制，但是带来的代价就是主瓣 有了适当扩展</p>
<h3 id="hamming-加权"><a href="#hamming-加权" class="headerlink" title="hamming 加权"></a>hamming 加权</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/dN1erHmp7KRByaX.png" alt=""></p>
<h2 id="2-5、零点调向（null-steering-sidelobe-canceller）"><a href="#2-5、零点调向（null-steering-sidelobe-canceller）" class="headerlink" title="2.5、零点调向（null steering / sidelobe canceller）"></a>2.5、零点调向（null steering / sidelobe canceller）</h2><p>有时，我们希望阵列在某个或某些方向上的响应为零（或者响应尽可能小），这些方向称作零点<br>（null）方向。<br>目标：设计权值向量，满足特定的约束条件：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\left\{\begin{array}{c}
\mathbf{w}^{H} \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{T}\right)=1 (无畸变响应约束)\\
\mathbf{w}^{H} \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{i}\right)=0,(零点约束)
\end{array} \quad i=1,2, \ldots, M_{0}\right. \\
&\mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{i}\right)=\left[\begin{array}{c}
e^{-j \mathbf{k}_{i}^{T}} \mathbf{p}_{0} \\
e^{-j \mathbf{k}_{i}^{T} \mathbf{p}_{1}} \\
\vdots \\
e^{-j \mathbf{k}_{i}^{T} \mathbf{p}_{N-1}}
\end{array}\right]
\end{aligned}</script><p>无畸变约束条件：对于$\mathbf{k_T}$方向入射来的信号能够无畸变的接收<br>零点约束条件:对于$\mathbf{k_i}$方向入射的信号希望能够尽可能地抑制或者消除</p>
<h3 id="零点调向"><a href="#零点调向" class="headerlink" title="零点调向"></a>零点调向</h3><p>目标：选择权值$𝐰$，满足零点约束条件，利用最小二乘原则，拟合一个理想方向图$𝐰_𝑑$。$𝐰_𝑑$一般用没有零点约束条件下的权值向量来代替。</p>
<p>把全部地$M_0$个零点约束条件，写成矩阵的形式————“零阶约束”</p>
<script type="math/tex; mode=display">
\mathbf{C}=\left[\mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{1}\right) ,\mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{2}\right) ,……,\mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{M_0}\right)   \right ]</script><p>则可以利用拉格朗日法，解决<strong>优化问题</strong>：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\min \varepsilon=\left\|\mathbf{w}_{d}-\mathbf{w}\right\|^{2} \\
\text { s.t. } \mathbf{w}^{H} \mathbf{C}=\mathbf{0}
\end{array}\right.</script><p>求解步骤</p>
<blockquote>
<p>目标函数:</p>
<script type="math/tex; mode=display">
\mathcal{L}=\left(\mathbf{w}_{d}-\mathbf{w}\right)^{H}\left(\mathbf{w}_{d}-\mathbf{w}\right)+\mathbf{w}^{H} \mathbf{C} \lambda+\lambda^{H} \mathbf{C}^{H} \mathbf{w},</script><p>对w求导得到:</p>
<script type="math/tex; mode=display">
-\mathbf{w}_{d}^{H}+\mathbf{w}^{H}+\lambda^{H} \mathbf{C}^{H}=\mathbf{0}</script><p>将约束条件 $\mathbf{w}^{H} \mathbf{C}=\mathbf{0}$ 代入(6.24)式，求出拉格朗日因子:</p>
<script type="math/tex; mode=display">
\lambda^{H}=\mathbf{w}_{d}^{H} \mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1}</script><p>求得最优权值:</p>
<script type="math/tex; mode=display">
\mathbf{w}^{H}=\mathbf{w}_{d}^{H}-\lambda^{H} \mathbf{C}^{H}=\mathbf{w}_{d}^{H}\left(\mathbf{I}_{N}-\mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{C}^{H}\right)</script><p>结论：最优权值是从理想权值中减去一个由约束矢量的线性组合形成的一个分量</p>
<p>投影矩阵和正交投影矩阵 :</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\mathbf{P}_{\mathbf{C}}=\mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{C}^{H} \\
&\mathbf{P}_{\mathbf{C}}^{\perp}=\mathbf{I}_{N}-\mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{C}^{H}
\end{aligned}</script><p>容易验证， $\mathbf{P}_{\mathbf{C}}$ 和 $\mathbf{P}_{\mathbf{C}}^{\perp}$ 既是 “幂等矩阵”，又是 “共轭对称矩阵”，所以它们都属于投影矩阵。且$\mathbf{P}_{\mathbf{C}}$ 与 $\mathbf{P}_{\mathbf{C}}^{\perp}$ 相互垂直。<br>因此 :</p>
<script type="math/tex; mode=display">
\mathbf{w}^{H}=\mathbf{w}_{d}^{H} \mathbf{P}_{\mathbf{C}}^{\perp}</script><p>举一个形象点的例子，如果我们已经有了理想的权值向量$\mathbf{W}_d$（他是没有零点约束情况下的向量），如果希望它能够满足一个约束条件，约束条件由平面$\mathbf{P}_{\mathbf{C}}$ 构成（可以理解为由约束矩阵C的各个列向量张成的线性空间），那么最优的  权值向量 $W$ 应该在这个平面上没有任何分量，也即应该垂直于该 约束平面。而垂直于该平面的向量为$\mathbf{P}_{\mathbf{C}}^{\perp}\mathbf{W}_d$,即为所求。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/xplCFPiuUbRNS5M.png" alt=""></p>
</blockquote>
<p>下图是对145°方向进行了一个零点约束的结果。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/oyPwODRbWFtrZnU.png" alt=""></p>
<h1 id="三、常见的波束形成方法"><a href="#三、常见的波束形成方法" class="headerlink" title="三、常见的波束形成方法"></a>三、常见的波束形成方法</h1><p>Delay-and-sum（DS）<br>Minimum Variance Distortionless Response（MVDR）<br>Linearly Constrained Minimum Variance（LCMV）<br>Generalized Sidelobe Canceller（GSC）</p>
<h2 id="3-1、Delay-and-sum-DS-Beamformer"><a href="#3-1、Delay-and-sum-DS-Beamformer" class="headerlink" title="3.1、Delay-and-sum (DS) Beamformer"></a>3.1、Delay-and-sum (DS) Beamformer</h2><p><strong>延迟求和波束形成方法</strong><br>虽然延迟求和波束形成（常规波束形成）对于干扰的抑制作用，尤其是对方向性干扰的抑制效果并不是最好的，但是但他对于目标方向上接受的稳定性确实最高的。所以实际项目当中也有很多的应用场景，比如GSC方法的魔魁啊中就用到了 DS Beamformer<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/hrgUtnaD5K43uwQ.png" alt=""></p>
<h2 id="3-2、Minimum-Variance-Distortionless-Response（MVDR）"><a href="#3-2、Minimum-Variance-Distortionless-Response（MVDR）" class="headerlink" title="3.2、Minimum Variance Distortionless Response（MVDR）"></a>3.2、Minimum Variance Distortionless Response（MVDR）</h2><p><strong>最小方差无畸变响应 波束形成器</strong></p>
<p>语音信号从已知方向𝐤𝑠入射，我们推导出最优波束形成器，提供对目标语音的最小方差无偏估计，得到无畸变波束形成器MVDR，或者Capon波束形成器。</p>
<p>考虑一个信号+ 噪声 的模型</p>
<script type="math/tex; mode=display">
\mathbf{X}(\omega)=\mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right) X(\omega)+\mathbf{N}(\omega)=\mathbf{X}_{s}(\omega)+\mathbf{N}(\omega)</script><p>目标：希望利用$\mathbf{X}(\omega)$得到关于$X(\omega)$的无偏、最小方差估计。<br>方案：在满足无畸变接收的前提下，寻找最优权值 $\mathbf{w}^{H}$ ，最小化输出功率（方差）</p>
<script type="math/tex; mode=display">
\begin{aligned}
E|Y(\omega)|^{2}=E\left|\mathbf{w}^{H} \mathbf{X}(\omega)\right|^{2} &=\mathbf{w}^{H} E\left[\mathbf{X}(\omega) \mathbf{X}^{H}(\omega)\right] \mathbf{w} \\
&=\mathbf{w}^{H} \mathbf{R}_{\mathbf{x x}}(\omega) \mathbf{w}
\end{aligned}</script><p>求解如下优化问题：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\min \mathbf{w}^{H} \mathbf{R}_{\mathbf{x x}}(\omega) \mathbf{w} \\
\text { s.t. } \mathbf{w}^{H} \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)=1
\end{array}\right.</script><p>通过拉格朗日乘子法，得到最优解，也即capon最优解 :</p>
<script type="math/tex; mode=display">
\mathbf{w}_{c}=\frac{\mathbf{R}_{\mathbf{X X}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}{\mathbf{v}_{\mathbf{k}}^{H}\left(\mathbf{k}_{s}\right) \mathbf{R}_{\mathbf{X X}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}</script><p>可以看出，结果主要取决于两个变量，<br>第一个就是阵列流形矢量。也即必须要知道或者准确的估计到信号的入射方向。<br>第二个是信号的相关矩阵。</p>
<p>可以使用 $\mathbf{R}_{\mathbf{n n}}(\omega)$ 代替 $\mathbf{R}_{\mathrm{xx}}(\omega)$ :<br>可以这样理解，我们在求解的过程中，已经在语音信号的方向上施加了一个无畸变约束，这就相当于我们在语音信号保持不变的前提下使得总的输出方差最小。那么达成目标的手段就仅需将噪声最小化，所以很多时候可以将噪声的相关矩阵来代替接收信号的相关矩阵。</p>
<script type="math/tex; mode=display">
\mathbf{w}_{c}=\frac{\mathbf{R}_{\mathbf{n n}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}{\mathbf{v}_{\mathbf{k}}^{H}\left(\mathbf{k}_{s}\right) \mathbf{R}_{\mathbf{n n}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}</script><ul>
<li>MVDR是一种自适应波束形成器，而DS是固定波束形成器。</li>
<li>当各个通道的噪声互不相关，并且具有相同功率的时候，MVDR退化成DS。</li>
<li>如果噪声是一个点声源，MVDR会自适应地在噪声方向形成一个零点。</li>
<li>MVDR的性能依赖于对阵列流形矢量𝐯𝐤 𝐤𝑠 和相关矩阵𝐑𝐧𝐧(𝜔) 的估计。</li>
<li>对MVDR的约束条件进行扩展，可以得到LCMV</li>
</ul>
<h2 id="3-3、Linearly-Constrained-Minimum-Variance-LCMV"><a href="#3-3、Linearly-Constrained-Minimum-Variance-LCMV" class="headerlink" title="3.3、Linearly Constrained Minimum Variance (LCMV)"></a>3.3、Linearly Constrained Minimum Variance (LCMV)</h2><p><strong>线性约束最小方差波束形成器</strong></p>
<p>考虑将MVDR中的约束条件扩展（MVDR中只有一个无畸变约束条件），来保证波束形成器更加稳健（也叫<strong>Frost Beamformer</strong>）</p>
<p>约束矩阵为C，维数 $N \times M_{0}$ ，第一列为无畸变约束，即 $\mathrm{g}$ 的第一个元素为 1 ，则约束条件变为:</p>
<script type="math/tex; mode=display">
\mathbf{C}^{H} \mathbf{w}=\mathbf{g}</script><p>目标函数依然是最小方差:</p>
<script type="math/tex; mode=display">
\min \mathbf{w}^{H} \mathbf{R}_{\mathbf{x x}}(\omega) \mathbf{w}</script><p>根据拉格朗日乘子法得到最优权重:</p>
<script type="math/tex; mode=display">
\mathbf{w}_{F}=\mathbf{R}_{\mathrm{XX}}^{-1}(\omega) \mathbf{C}\left(\mathbf{C}^{H} \mathbf{R}_{\mathrm{XX}}^{-1}(\omega) \mathbf{C}\right)^{-1} \mathbf{g}</script><p>可以看到，LCMV是一种更为通用的方案，它是对MVDR方案只有一个约束条件的特例进行了扩展。</p>
<h2 id="3-4、Generalized-Sidelobe-Canceller-GSC"><a href="#3-4、Generalized-Sidelobe-Canceller-GSC" class="headerlink" title="3.4、Generalized Sidelobe Canceller (GSC)"></a>3.4、Generalized Sidelobe Canceller (GSC)</h2><p><strong>广义旁瓣消除</strong></p>
<p>LCMV的等效实现方式。从结构上将LCMV的<strong>约束优化问题</strong>转化为<strong>无约束优化问题</strong>。</p>
<p>方法：将LCMV的最优权重向量，分解为非自适应（固定）权重和自适应（非固定）权重两部分。非自适应权重位于约束子空间中，自适应权重位于约束子空间的正交补空间中。</p>
<p>约束子空间  由约束矩阵 $\mathrm{C}$ 的列向量张成， $N \times M_{0}$ ；<br>约束子空间的正交补空间由 $\mathbf{B} ， N \times\left(N-M_{0}\right)$ ，且满足 :</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\mathbf{C}^{H} \mathbf{B}=\mathbf{0} \\
&\mathbf{B}^{H} \mathbf{C}=\mathbf{0}
\end{aligned}</script><p>我们试图将权值向量$\mathbf{w}$分解到这两个正交补空间当中。<br>也即，将权重向量 $\mathbf{w}$ 表示为固定分量 $\mathbf{w}_{q}$ 与自适应分量 $\mathbf{w}_{p}$ 两部分:</p>
<script type="math/tex; mode=display">
\mathbf{w}=\mathbf{w}_{q}-\mathbf{w}_{p}</script><p>其中， $\mathbf{w}_{q}$ 表示权重向量 $\mathbf{w}$ 向约束子空间（也就是C张成的空间）的投影:</p>
<script type="math/tex; mode=display">
\mathbf{w}_{q}=\mathbf{P}_{\mathbf{C}} \mathbf{w}=\mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{C}^{H} \mathbf{w}=\mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{g}</script><p>$\mathbf{w}_{p}$ 表示权重向量 $\mathbf{W}$ 向正交子空间（也就是B张成的空间）的投影:</p>
<script type="math/tex; mode=display">
\mathbf{w}_{p}=\mathbf{P}_{\mathbf{B}} \mathbf{w}=\mathbf{B}\left(\mathbf{B}^{H} \mathbf{B}\right)^{-1} \mathbf{B}^{H} \mathbf{w}=\mathbf{B} \mathbf{w}_{a}</script><p>于是，我们得到GSC结构:</p>
<script type="math/tex; mode=display">
\mathbf{w}_{g s c}=\mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{g}-\mathbf{B} \mathbf{w}_{a}=\mathbf{w}_{q}-\mathbf{B} \mathbf{w}_{a}</script><p>可见 GSC 得到的权值向量 由 三个要素组成</p>
<ul>
<li>$\mathbf{w}_{q}$ 固定波束形成分量，对应着 GSC 的固定波束形成模块。</li>
<li>$\mathbf{B} $矩阵是约束空间的正交补空间，再GSC框架下，我们称之为阻塞矩阵。作用是阻塞 关键语音成分，而把干扰 露进来？</li>
<li>$ \mathbf{w}_{a}$ ,是对应着GSC 自适应干扰消除模块</li>
</ul>
<p>此外，B矩阵的选取并非唯一，</p>
<ul>
<li>一种选取方式是，C矩阵已知，求取C的正交投影矩阵 ，选择正交投影矩阵的前$N-M_{0}$列</li>
</ul>
<h3 id="GSC-各个模块-的物理意义"><a href="#GSC-各个模块-的物理意义" class="headerlink" title="GSC 各个模块 的物理意义:"></a>GSC 各个模块 的物理意义:</h3><p>(1) FBF（固定波束形成） 用于生成 $\mathbf{w}_{q}$， 是一个 “固定旁瓣对消器”<br>$\mathbf{w}_{q}$，没有任何自适应成分，且满足约束条件:</p>
<script type="math/tex; mode=display">
\mathbf{C}^{H} \mathbf{w}_{q}=\mathbf{C}^{H} \mathbf{C}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{g}=\mathbf{g}</script><p>在实际场景中，我们认为$\mathbf{w}_{q}$ 只需要有一个无畸变约束就够了，而零点约束也可以放在自适应部分，也即正交补空间的部分。当然如果我们确定干扰信号来自确定的方向时，可以扩展约束条件，追加一些零点约束，形成一些固定方向的零点，大多数时候，干扰信号方向时不知道的，所以不会这样做。</p>
<p>剩下两部分负责生成 与 $\mathbf{w}_{q}$，正交的部分。<br>即 “正交分解”，生成满足 $\mathbf{w}_{q} \perp \mathbf{B w}_{a}$条件的$\mathbf{B w}_{a}$部分，也即自适应部分 :<br>(2)、BM  （阻塞矩阵）<br>(3)、ANC （自适应噪声相消器）</p>
<script type="math/tex; mode=display">
\mathbf{w}_{q}^{H} \mathbf{B} \mathbf{w}_{a}=\mathbf{g}^{H}\left(\mathbf{C}^{H} \mathbf{C}\right)^{-1} \mathbf{C}^{H} \mathbf{B} \mathbf{w}_{a}=0</script><p>所以：总体而言，广义旁瓣对消器(GSC) = 固定旁瓣对消器  + 与之正交的自适应旁瓣对消器</p>
<p>GSC的框图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/AhiycZRo4Ga15LY.png" alt=""><br>由于上半部分固定，所以整个系统的关键在于阻塞矩阵$\mathbf{B}$的求解，希望通过设计阻塞矩阵使得语音信号尽可能少的泄漏到自适应部分</p>
<p>我们当然可以显示的求解$\mathbf{w}_{a}$的表达形式，它等价于一个无约束最优化问题：</p>
<script type="math/tex; mode=display">
\min \left(\mathbf{w}_{q}-\mathbf{B} \mathbf{w}_{a}\right)^{H} \mathbf{R}_{\mathbf{x x}}\left(\mathbf{w}_{q}-\mathbf{B} \mathbf{w}_{a}\right)</script><ul>
<li>GSC通过“正交分解”的方式，将LCMV约束优化问题，转化为无约束优化问题。</li>
<li>“主路”和“辅路”。目标语音从“主路”通过，尽可能不要泄漏到“辅路”。</li>
<li>GSC的自适应实现方式</li>
</ul>
<h3 id="GSC算法的实现方式："><a href="#GSC算法的实现方式：" class="headerlink" title="GSC算法的实现方式："></a>GSC算法的实现方式：</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/30/2h6NWPg53XAKTmr.png" alt=""></p>
<p>参考：Efficient Frequency-domain realization of Robust Generalized Sidelobe Cancellers. W. Herbordt, W. Kellermann<br>在开源项目 Athena signal ， athena beamformer 模块 就是采用这样的方法实现的</p>
<h4 id="FBF-Fixed-Beamforming"><a href="#FBF-Fixed-Beamforming" class="headerlink" title="FBF- Fixed Beamforming"></a>FBF- Fixed Beamforming</h4><p>可以将Delay-and-sum beamformer 方案作为 固定波束形成模块</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/30/DHznXRqumbPOZ14.png" alt=""></p>
<ul>
<li><p>先决条件 ： 声源入射方向已知 （或者可以可靠的估计出来）</p>
</li>
<li><p>步骤： </p>
<ul>
<li>采用主波束调向（beam steering），将方向向量调整至声源入射方向，对齐每个方向的语音分量</li>
<li>求和 得到 $y_f(n)=\sum^{M-1}_{m=0}x_m(n)$</li>
<li>求和结果 作为 ABM模块的输入信号，以及AIC模块的期望输出信号</li>
</ul>
</li>
</ul>
<h4 id="ABM-–-Adaptive-Blocking-Matrix"><a href="#ABM-–-Adaptive-Blocking-Matrix" class="headerlink" title="ABM – Adaptive Blocking Matrix"></a>ABM – Adaptive Blocking Matrix</h4><ul>
<li>由M条通路构成</li>
<li>每条通路包含一个自适应滤波器</li>
<li>每一条通路的滤波器能够  自适应消除语音分量，而把噪声或者干扰分量尽可能保留</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/30/OBMo1XgfjREm9Wq.png" alt=""></p>
<p>△ 自适应滤波输入：$y_f(n)$<br>△ 期望信号 ：delay of $x_m(n)$</p>
<p>此外，这个模块还需要一个 类似于 回声消除一样来控制自适应滤波状态的一个机制<br>由于目标是消除语音分量，所以只有语音存在的时候才做更新，语音不存在时仅作滤波即可。Active during speech presence</p>
<p>所以这就是一个典型的自适应滤波任务。我们可以利用频率自适应滤波来实现它。</p>
<p>以第m个通道 为例:<br>FBF输出 $y_{f}(n)$ 的频域表示（时域y(t)有新旧两个Block拼接而成,长度 2L）:</p>
<script type="math/tex; mode=display">
\mathbf{Y}_{f}(k)=\operatorname{diag}\left\{\mathbf{F}\left(y_{f}(k L-L), \ldots, y_{f}(k L), \ldots, y_{f}(k L+L-1)\right)^{T}\right\}</script><p>ABM自适应滤波器系数（由 L长 系数，后面补 L个零 拼接而成）：</p>
<script type="math/tex; mode=display">
\mathbf{H}_{b}^{(m)}(k)=\mathbf{F}\left(h_{b, 0}^{(m)}(k), \ldots, h_{b, L-1}^{(m)}(k), \quad \mathbf{0}_{1 \times L}\right)^{T},</script><p>滤波，频域输出信号为:</p>
<script type="math/tex; mode=display">
\mathbf{Y}_{b}^{(m)}(k)=\mathbf{Y}_{f}(k) \mathbf{H}_{b}^{(m)}(k)</script><p>注意到，ABM模块的输出（真正有用的）是滤波后的误差信号，下面是计算误差信号的步骤：</p>
<p>时域误差信号（时域上进行，期望输出减去 实际的滤波器输出）:<br>期望信号是第$m$个阵元的接收信号，是经过时延处理的，时延的目的是使满足时间上的因果关系。</p>
<script type="math/tex; mode=display">
\mathbf{e}_{b}^{(m)}(k)=\mathbf{x}_{m}\left(k-\frac{\kappa_{b}}{L}\right)-\mathbf{w} \mathbf{F}^{-1} \mathbf{Y}_{f}(k) \mathbf{H}_{b}^{(m)}(k)</script><p>其中:</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathbf{w}=\operatorname{diag}\left\{\left(\mathbf{0}_{1 \times L}, \mathbf{1}_{1 \times L}\right)\right\} \\
\mathbf{x}_{m}(k)=\left(\mathbf{0}_{1 \times L}, \quad x_{m}(k L), \ldots, x_{m}(k L+L-1)\right)^{T}
\end{gathered}</script><p>$\mathbf{w}$矩阵的目的是:只取输出的后$L$个。</p>
<p>则无约束ABM滤波器的更新公式:</p>
<script type="math/tex; mode=display">
\mathbf{H}_{b}^{(m)}(k+1)=\mathbf{H}_{b}^{(m)}(k)+\boldsymbol{\mu}(k) \mathbf{Y}_{f}^{H}(k) \mathbf{E}_{b}^{(m)}(k)</script><p>Active during speech presence</p>
<p>步长矩阵:</p>
<script type="math/tex; mode=display">
\boldsymbol{\mu}(k)=2 \mu \operatorname{diag}\left\{P_{0}^{-1}(k) \cdots P_{2 L-1}^{-1}(k)\right\}</script><p>注意这个更新过程要区分那些部分是圆周卷积，那些是线性卷积。</p>
<p>频点功率依旧采用迭代更新:</p>
<script type="math/tex; mode=display">
P_{l}(k)=\lambda P_{l}(k-1)+(1-\lambda)\left|Y_{f, l}(k)\right|^{2}, \quad l=0, \ldots, 2 L-1</script><p>$Y_{f, l}(k)$ 是 $\mathbf{Y}_{f}(k)$ 的第 $l$ 个frequency bin。</p>
<h4 id="AIC-–-Adaptive-Interference-Canceller"><a href="#AIC-–-Adaptive-Interference-Canceller" class="headerlink" title="AIC – Adaptive Interference Canceller"></a>AIC – Adaptive Interference Canceller</h4><ul>
<li>由 M 条通路构成。</li>
<li>每条通路包含一个自适应滤波器：</li>
<li>自适应滤波器输出结果求和——Interference</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/30/kjGyLJPdQgs4SRl.png" alt=""></p>
<p>△ 输入：ABM的输出信号 $\mathbf{E}_{b}^{(m)}(k)$ ,也即上一步 干扰信号的频域形式<br>△ 期望输入：delay of $y_f(n)$</p>
<p>这一部分是尽量提取出来接收信号中的干扰成分，所以只有干扰存在时（语音信号不存在时）才进行更新，其他时间 Active during speech absence</p>
<p>所以，AIC 任然可以用一种标准的 频域自适应滤波的方案来实现。</p>
<p>$\mathrm{AlC}$ 的输入:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{X}_{a}^{(m)}(k)=\operatorname{diag}\left\{\mathbf{E}_{b}^{(m)}(k)\right.&\left.+\mathbf{J} \mathbf{E}_{b}^{(m)}(k-1)\right\}, \\
\mathbf{J}=\operatorname{diag}\left\{(1,-1,1, \ldots,-1)_{1 \times 2 L}\right\},
\end{aligned}</script><p>PS：可以证明，这种输入形式在时域上等价于 old block 与 new block 拼接在一起。<br>则AIC的时域误差信号:</p>
<script type="math/tex; mode=display">
\mathbf{e}_{a}(k)=\mathbf{y}_{f}(k)-\mathbf{y}_{a}(k),</script><p>其中:</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathbf{y}_{f}(k)=\left(0_{1 \times L}, \quad y_{f}\left(k L-\kappa_{a}\right), \ldots, y_{f}\left(k L+L-1-\kappa_{a}\right)\right)^{T}, \\
\mathbf{y}_{a}(k)=\mathbf{W ~ F}^{-1} \sum_{m=0}^{M-1} \mathbf{X}_{a}^{(m)}(k) \mathbf{H}_{a}^{(m)}(k)
\end{gathered}</script><p>$\mathrm{AIC}$ 自适应滤波器更新公式：</p>
<script type="math/tex; mode=display">
\mathbf{H}_{a}^{(m)}(k+1)=\mathbf{H}_{a}^{(m)}(k)+\boldsymbol{\mu}(k) \mathbf{X}_{a}^{(m) H}(k) \mathbf{E}_{a}(k),</script><p>步长矩阵仍然按照ABM模块的定义来做，其中频点功率按照如下方式迭代:</p>
<script type="math/tex; mode=display">
P_{l}(k)=\lambda P_{l}(k-1)+(1-\lambda) \sum_{m=0}^{M-1}\left|X_{a, l}(k)\right|^{2}</script><p>GSC的最终输出是AIC误差信号 $\mathbf{e}_{a}(k)$ 的后 $L$ 个点。</p>
<h1 id="四、声源定位技术"><a href="#四、声源定位技术" class="headerlink" title="四、声源定位技术"></a>四、声源定位技术</h1><p>所谓声源定位就是确定声源的“方位信息”</p>
<p>影响声源定位精度的  因素：</p>
<ul>
<li>麦克风的数量</li>
<li>阵列构型以及阵列于声源的相对位置关系（如线性阵列于环形阵列对于不同角度的搜索能力有差别）</li>
<li>背景噪声和混响</li>
</ul>
<p>从技术上看，传统的声源定位技术大致可以分为三大类（三个方向）</p>
<ul>
<li>Maximizing the Steered-response-power（SRP）<br>最大化可控响应功率（最大化输出功率）</li>
<li>High-resolution spectral-estimation<br>高分辨率普估计技术</li>
<li>Time difference of arrival (TDOA)<br>到达时间差</li>
</ul>
<p>摘自：Brandstein, Ward. Microphone Arrays: Signal Processing Techniques and Applications</p>
<h2 id="4-1、Maximizing-the-Steered-response-power（SRP）"><a href="#4-1、Maximizing-the-Steered-response-power（SRP）" class="headerlink" title="4.1、Maximizing the Steered-response-power（SRP）"></a>4.1、Maximizing the Steered-response-power（SRP）</h2><p> 原理就是通过调向，找到一个输出功率最大的方向，认为那个方向就是声源的入射方向。<br> “A focused beamformer which steers the array to various locations and searches for a peak in output power.”</p>
<p>以 ULA主波束调向（beam steering）为例<br>调整频率-波数响应函数：</p>
<script type="math/tex; mode=display">
\Upsilon\left(\omega, \mathbf{k}-\mathbf{k}_{T}\right) \leftarrow \Upsilon(\omega, \mathbf{k})</script><p>修正权值向量:</p>
<script type="math/tex; mode=display">
\mathbf{w}_{T} \leftarrow\left[\begin{array}{c}
e^{j \mathbf{k}_{T}^{T} \mathbf{p}_{0}} \\
e^{j \mathbf{k}_{T}^{T} \mathbf{p}_{1}} \\
\vdots \\
e^{j \mathbf{k}_{T}^{T} \mathbf{p}_{N-1}}
\end{array}\right] \odot \mathbf{w}</script><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/28/JC1r8h7nuGQ4PyK.png" alt=""></p>
<p>通过空间扫描，将主波束从0°扫描至180°，只有当主瓣刚好对应到相应的声源入射方向时，输出功率才最大。</p>
<h3 id="SRP-based-Source-Localization"><a href="#SRP-based-Source-Localization" class="headerlink" title="SRP-based Source Localization"></a>SRP-based Source Localization</h3><p>方案：利用Delay-and-sum波束形成，在每一路输入信号中施加适当的延迟项，补偿声源方向到达<br>麦克风阵列产生的时间差，从而将各个通道中的语音信号成分时间对齐，得到输出信号。</p>
<p>步骤：<br>阵列输入信号 (共有N个阵元，下面是阵元在n时刻的采样数据):</p>
<script type="math/tex; mode=display">
\mathbf{x}(n)=\left[\begin{array}{c}
x_{0}(n) \\
x_{1}(n) \\
\vdots \\
x_{N-1}(n)
\end{array}\right]</script><p>经过Delay-and-sum波束形成后的输出信号为：</p>
<script type="math/tex; mode=display">
y(n)=\sum_{i=0}^{N-1} x_{i}\left(n+\Delta_{i}\right)</script><p>其中 $\Delta_{i}, i=0,1, \ldots, N-1$ 称作 steering delays（调向延时）</p>
<p>当我们把阵列的主波束调向至不同的空间方位时，会产生不同的调向延迟 $\Delta_{i}$ 。显然，Delay-and-sum波束形成的输出信号 $y(n)$ 与主波束的指向相关，故将其记作 $y\left(n, \mathbf{k}_{s}\right)$ ，即：</p>
<script type="math/tex; mode=display">
y\left(n, \mathbf{k}_{s}\right)=\sum_{i=0}^{N-1} x_{i}\left(n+\Delta_{i}\right)</script><p>实际中，由于麦克风阵列的几何布局是已知的，因此，可以选定一个麦克风作为参考麦克风，计算 声源到达各个麦克风与参考麦克风之间的到达时间差 (TDOA) ，用 $\tau$ 表示（对于ULA通常将最边上的麦克风作为参考，对于环形阵列，通常假设环形中心有一个麦克风，来作为参考），从而将计算绝对延时转 化为计算相对延时。<br>(7.3)式的频域等价形式为:</p>
<script type="math/tex; mode=display">
Y\left(\omega, \mathbf{k}_{s}\right)=\sum_{i=0}^{N-1} X_{i}(\omega) e^{j \omega \Delta_{i}}</script><blockquote>
<p>如想将延迟求和转换为更一般的情况，卷积上一个滤波器系数即可<br>则频域将变成</p>
<script type="math/tex; mode=display">
Y\left(\omega, \mathbf{k}_{s}\right)=\sum_{i=0}^{N-1} G_{i}(\omega) X_{i}(\omega) e^{j \omega \Delta_{i}}</script><p>计算SRP :</p>
<script type="math/tex; mode=display">
P(\mathbf{k})=\int_{-\infty}^{\infty}|Y(\omega, \mathbf{k})|^{2} d \omega</script><p>遍历所有方向$\mathbf{k}$，Maximizing  SRP :</p>
<script type="math/tex; mode=display">
\hat{\mathbf{k}}_{s}=\underset{\mathbf{k}}{\operatorname{argmax}} P(\mathbf{k})</script><p>“Delay-and-sum SRP” or “Filter-and-sum SRP”</p>
</blockquote>
<p>以上就是SRP的基本思想以及步骤，这种方法在噪声比较弱的情况下，性能比较好。但是当噪声和混响比较大的时候性能就会恶化。</p>
<p>为了改进这个状况，有人利用加权的方案来优化SRP方案<br>借鉴GCC（广义互相关）方法中的PHAT（相位变换加权）加权思想（起到了一种白化的作用，相当于把有关幅度相关的信息全部归一化掉了，而只保留关于相位的信息，而我们所想要估计的时延其实都保留在了相位信息当中）<br>借鉴GCC方法中的PHAT加权思想，定义SRP-PHAT方法 :</p>
<script type="math/tex; mode=display">
P(\mathbf{k})=\sum_{i=0}^{N-1} \sum_{l=0}^{N-1} \int_{-\infty}^{\infty} \Psi_{i l}(\omega) X_{i}(\omega) X_{l}^{*}(\omega) e^{j \omega \tau_{i l}} d \omega</script><p>PS:这个公式相当于遍历所有可能的 阵元对（麦克风对）<br>其中 $\Psi_{i l}(\omega)$ 为PHAT加权函数 :</p>
<script type="math/tex; mode=display">
\Psi_{i l}(\omega)=G_{i}(\omega) G_{l}^{*}(\omega)=\frac{1}{\left|X_{i}(\omega) X_{l}^{*}(\omega)\right|}</script><p>上式，是SRP-PHAT的频域表达形式。相对应的时域表达形式为 :</p>
<script type="math/tex; mode=display">
P(\mathbf{k})=2 \pi \sum_{i=0}^{N-1} \sum_{l=0}^{N-1} r_{i l}\left(\tau_{i l}\right)</script><p>其中$ r_{i l}\left(\tau_{i l}\right)$是 广义互相关函数<br>后面的步骤和标准的 SRP一样了，都是遍历所有方向然后 找最大的方向。</p>
<p>SRP-PHAT相当于 N 元麦克风阵列中，对于入射方位𝐤而言，计算所有可能的“麦克风对”（possible pairwise）的广义互相关函数之和（还包括N个零延时的广义自相关函数之和）。<br>对于只有两个麦克风所组成的阵列，SRP-PHAT等价于广义互相关法（GCC）。随着麦克风数目的增多，GCC方法扩展成为SRP-PHAT方法。<br>SRP-PHAT运算量偏大，通常需要权衡搜索精度和运算量之间的关系</p>
<h2 id="4-2、High-resolution-spectral-estimation"><a href="#4-2、High-resolution-spectral-estimation" class="headerlink" title="4.2、High-resolution spectral estimation"></a>4.2、High-resolution spectral estimation</h2><p>即基于高分辨率普估计的声源定位技术。<br>这种技术分为两个大的子方向。</p>
<ul>
<li>1、Minimum variance (MV) spectral estimation （基于最小方差的谱估计技术） </li>
<li>2、Eigen-analysis-based techniques （基于特征值分析的谱估计是几乎）</li>
</ul>
<p>无论哪种方向，计算的核心都是对于阵列信号相关矩阵$\mathbf{R}_{\mathbf{xx}}$的估计。</p>
<p>功率谱密度描述信号功率随频率的分布，是信号的一种频域表示。由于阵列信号处理的主要任务之一是信号的空间参数估计（如DOA估计），所以将功率谱密度的概念在空域加以延伸就显得十分重要。这种广义的功率谱常简称为<strong>空间谱</strong>。空间谱描述了信号的空间参数的分布。</p>
<p>回顾MVDR Beamformer：</p>
<script type="math/tex; mode=display">
\mathbf{w}_{c}=\frac{\mathbf{R}_{\mathbf{X X}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}{\mathbf{v}_{\mathbf{k}}^{H}\left(\mathbf{k}_{s}\right) \mathbf{R}_{\mathbf{X X}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}</script><p>MVDR使得目标方向以外的任何干扰贡献的功率最小，同时保持目标方向上的信号功率（无畸变约束，保持目标方向上的功率不变），可视为一种<strong>空间带通滤波器</strong>。<br>MVDR最优波束形成的必要条件 : 波达方向 $\mathbf{k}_{s}$ 的估计。</p>
<p>最优权重 $\mathbf{w}_{c}$ ，带入输出功率当中，得到以下的阵列输出功率 :</p>
<script type="math/tex; mode=display">
P\left(\mathbf{k}_{s}\right)=\mathbf{w}_{c}^{H} \mathbf{R}_{\mathbf{x x}}(\omega) \mathbf{w}_{c}=\frac{1}{\mathbf{v}_{\mathbf{k}}^{H}\left(\mathbf{k}_{s}\right) \mathbf{R}_{\mathbf{x x}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}\left(\mathbf{k}_{s}\right)}</script><p>可以把上式视为一种“空间功率谱”，以空间方位$\mathbf{k}_{s}$的变化而变化。<br>定义这种功率谱为 “空间功率谱”（Capon 谱）</p>
<script type="math/tex; mode=display">
P_{\text {Capon }}(\mathbf{k})=\frac{1}{\mathbf{v}_{\mathbf{k}}^{H}(\mathbf{k}) \mathbf{R}_{\mathbf{x X}}^{-1}(\omega) \mathbf{v}_{\mathbf{k}}(\mathbf{k})}</script><p>其峰值对应的入射方向就是声源的入射方向：</p>
<script type="math/tex; mode=display">
\hat{\mathbf{k}}_{S}=\underset{\mathbf{k}}{\operatorname{argmax}} P_{\text {Capon }}(\mathbf{k})</script><p>这就是基于最小方差（MV ) 的空间谱估计方法。</p>
<p>在这个方向中衍生出一种 基于特征值分析的方法 : multiple signal classification，<strong>MUSIC 算法</strong></p>
<script type="math/tex; mode=display">
P_{\text {MUSIC }}(\mathbf{k})=\frac{1}{\mathbf{v}_{\mathbf{k}}^{H}(\mathbf{k}) \mathbf{G G}^{H} \mathbf{v}_{\mathbf{k}}(\mathbf{k})}</script><p>其中$\mathbf{G}$是我们算出自相关矩阵之后，通过特征值 求取的噪声子空间。</p>
<h2 id="TDOA-based-Source-Localization"><a href="#TDOA-based-Source-Localization" class="headerlink" title="TDOA-based Source Localization"></a>TDOA-based Source Localization</h2><p><strong>基于到达时间差的声源定位</strong></p>
<p>到达时间差（time difference of arrival,DOA）<br>时延估计（time dealy estimation，TDE）</p>
<p>原理<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/30/5PsJjmGXLRwpUSu.png" alt=""><br>仅根据时延$\tau$就可以倒推出方向$\theta$</p>
<p>再次回顾GCC(Generalized cross correlation)方案估计时延差<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/05/30/xVZ1nQ9trqJa6Og.png" alt=""></p>
<script type="math/tex; mode=display">
R_{i j}(\tau)=\frac{1}{2 \pi} \int_{-\infty}^{\infty} \Psi_{i j}(\omega) X_{i}(\omega) X_{j}^{*}(\omega) e^{j \omega \tau} d \omega</script></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">语音信号处理</a><a class="post-meta__tags" href="/tags/%E9%98%B5%E5%88%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">阵列信号处理</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/30/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89%20%E5%9F%BA%E4%BA%8EDNN%E7%9A%84%E8%AF%AD%E9%9F%B3%E5%88%86%E7%A6%BB/" title="语音信号处理（七） 基于DNN的语音分离"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">语音信号处理（七） 基于DNN的语音分离</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/23/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E5%A3%B0%E5%AD%A6%E5%9B%9E%E5%A3%B0%E6%B6%88%E9%99%A4/" title="语音信号处理（五）声学回声消除"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">语音信号处理（五）声学回声消除</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/16/%E3%80%8A%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E5%A4%84%E7%90%86%E3%80%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%20%E5%8F%91%E5%A3%B0%E6%9C%BA%E7%90%86/" title="《实时语音信号处理》学习笔记 信号处理基础 发声机理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-16</div><div class="title">《实时语音信号处理》学习笔记 信号处理基础 发声机理</div></div></a></div><div><a href="/2022/05/17/%E3%80%8A%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E5%A4%84%E7%90%86%E3%80%8B%E8%AF%AD%E9%9F%B3%E7%AB%AF%E7%82%B9%E6%A3%80%E6%B5%8B/" title="《实时语音处理》语音端点检测"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-17</div><div class="title">《实时语音处理》语音端点检测</div></div></a></div><div><a href="/2022/05/13/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E6%96%B9%E6%B3%95/" title="语音信号处理（三）自适应滤波方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">语音信号处理（三）自适应滤波方法</div></div></a></div><div><a href="/2022/05/13/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89DSP%E5%9F%BA%E7%A1%80/" title="语音信号处理（二）DSP基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">语音信号处理（二）DSP基础</div></div></a></div><div><a href="/2022/05/11/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/" title="语音信号处理（一）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-11</div><div class="title">语音信号处理（一）</div></div></a></div><div><a href="/2022/05/23/%E8%AF%AD%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E5%A3%B0%E5%AD%A6%E5%9B%9E%E5%A3%B0%E6%B6%88%E9%99%A4/" title="语音信号处理（五）声学回声消除"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-23</div><div class="title">语音信号处理（五）声学回声消除</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">taotaozi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/differencer"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/differencer?type=blog" target="_blank" title="Github"><i class="fab fa-CSDN"></i></a><a class="social-icon" href="https://space.bilibili.com/20713910" target="_blank" title="Bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="/473439851" target="_blank" title="steam"><i class="fab fa-steam"></i></a><a class="social-icon" href="https://weibo.com/u/5856795355" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="mailto:1359114644@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">最近的新任务是 ： 努力啊</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%98%B5%E5%88%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">一、阵列信号处理的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E9%98%B5%E5%88%97%E4%BF%A1%E5%8F%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.1、阵列信号模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%A2%E6%9D%9F%E6%88%90%E5%BD%A2"><span class="toc-text">二、波束成形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%B3%A2%E6%9D%9F%E5%BD%A2%E6%88%90%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1、波束形成的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E4%B8%BE%E4%BE%8B%EF%BC%8C%E4%BB%A5%E5%9D%87%E5%8C%80%E7%BA%BF%E6%80%A7%E9%98%B5%E5%88%97%EF%BC%88ULA%EF%BC%89%E4%B8%BA%E4%BE%8B"><span class="toc-text">2.2、举例，以均匀线性阵列（ULA）为例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E4%B8%BB%E6%B3%A2%E6%9D%9F%E8%B0%83%E5%90%91-beam-steering"><span class="toc-text">2.3、主波束调向(beam  steering)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E6%96%B9%E5%90%91%E5%9B%BE%E5%90%88%E6%88%90"><span class="toc-text">2.4、方向图合成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cosine-%E5%8A%A0%E6%9D%83"><span class="toc-text">cosine 加权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hamming-%E5%8A%A0%E6%9D%83"><span class="toc-text">hamming 加权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81%E9%9B%B6%E7%82%B9%E8%B0%83%E5%90%91%EF%BC%88null-steering-sidelobe-canceller%EF%BC%89"><span class="toc-text">2.5、零点调向（null steering &#x2F; sidelobe canceller）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%82%B9%E8%B0%83%E5%90%91"><span class="toc-text">零点调向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A2%E6%9D%9F%E5%BD%A2%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-text">三、常见的波束形成方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81Delay-and-sum-DS-Beamformer"><span class="toc-text">3.1、Delay-and-sum (DS) Beamformer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81Minimum-Variance-Distortionless-Response%EF%BC%88MVDR%EF%BC%89"><span class="toc-text">3.2、Minimum Variance Distortionless Response（MVDR）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81Linearly-Constrained-Minimum-Variance-LCMV"><span class="toc-text">3.3、Linearly Constrained Minimum Variance (LCMV)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81Generalized-Sidelobe-Canceller-GSC"><span class="toc-text">3.4、Generalized Sidelobe Canceller (GSC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GSC-%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97-%E7%9A%84%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89"><span class="toc-text">GSC 各个模块 的物理意义:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GSC%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">GSC算法的实现方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FBF-Fixed-Beamforming"><span class="toc-text">FBF- Fixed Beamforming</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABM-%E2%80%93-Adaptive-Blocking-Matrix"><span class="toc-text">ABM – Adaptive Blocking Matrix</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIC-%E2%80%93-Adaptive-Interference-Canceller"><span class="toc-text">AIC – Adaptive Interference Canceller</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A3%B0%E6%BA%90%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF"><span class="toc-text">四、声源定位技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81Maximizing-the-Steered-response-power%EF%BC%88SRP%EF%BC%89"><span class="toc-text">4.1、Maximizing the Steered-response-power（SRP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SRP-based-Source-Localization"><span class="toc-text">SRP-based Source Localization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81High-resolution-spectral-estimation"><span class="toc-text">4.2、High-resolution spectral estimation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TDOA-based-Source-Localization"><span class="toc-text">TDOA-based Source Localization</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/25/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%911-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发1-内容管理模块开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230525224811.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发1-内容管理模块开发"/></a><div class="content"><a class="title" href="/2023/05/25/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%911-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发1-内容管理模块开发">类MOOC系统开发1-内容管理模块开发</a><time datetime="2023-05-25T14:46:56.000Z" title="发表于 2023-05-25 22:46:56">2023-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/22/%E7%AE%97%E6%B3%95_%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98/" title="算法:单调栈问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230522212237.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法:单调栈问题"/></a><div class="content"><a class="title" href="/2023/05/22/%E7%AE%97%E6%B3%95_%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98/" title="算法:单调栈问题">算法:单调栈问题</a><time datetime="2023-05-22T13:20:06.000Z" title="发表于 2023-05-22 21:20:06">2023-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/22/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%910-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="类MOOC系统开发0-项目基础环境搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230522110116.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发0-项目基础环境搭建"/></a><div class="content"><a class="title" href="/2023/05/22/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%910-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="类MOOC系统开发0-项目基础环境搭建">类MOOC系统开发0-项目基础环境搭建</a><time datetime="2023-05-22T02:59:45.000Z" title="发表于 2023-05-22 10:59:45">2023-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/17/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/" title="算法：回溯问题 （未完待续~~）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230517165923.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法：回溯问题 （未完待续~~）"/></a><div class="content"><a class="title" href="/2023/05/17/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/" title="算法：回溯问题 （未完待续~~）">算法：回溯问题 （未完待续~~）</a><time datetime="2023-05-17T08:57:46.000Z" title="发表于 2023-05-17 16:57:46">2023-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/12/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发总结--内容管理模块开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230512175739.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发总结--内容管理模块开发"/></a><div class="content"><a class="title" href="/2023/05/12/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发总结--内容管理模块开发">类MOOC系统开发总结--内容管理模块开发</a><time datetime="2023-05-12T09:55:48.000Z" title="发表于 2023-05-12 17:55:48">2023-05-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://differencer.oss-cn-beijing.aliyuncs.com/img/cover(1).jpg.webp')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By taotaozi</div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'differencer/giscus',
    'data-repo-id': 'R_kgDOJMrL1A',
    'data-category-id': 'DIC_kwDOJMrL1M4CVC1y',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>