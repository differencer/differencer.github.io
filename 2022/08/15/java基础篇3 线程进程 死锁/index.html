<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java基础篇3 线程进程 死锁 | tのblog</title><meta name="author" content="taotaozi"><meta name="copyright" content="taotaozi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程线程和进程进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，⽽ main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。 线程 但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。与进程不同的是同类的多个线">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础篇3 线程进程 死锁">
<meta property="og:url" content="https://differencer.github.io/2022/08/15/java%E5%9F%BA%E7%A1%80%E7%AF%873%20%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%20%E6%AD%BB%E9%94%81/index.html">
<meta property="og:site_name" content="tのblog">
<meta property="og:description" content="多线程线程和进程进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，⽽ main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。 线程 但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。与进程不同的是同类的多个线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://differencer.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-08-15T15:28:35.000Z">
<meta property="article:modified_time" content="2023-04-03T09:44:01.686Z">
<meta property="article:author" content="taotaozi">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="java基础">
<meta property="article:tag" content="死锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://differencer.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://differencer.github.io/2022/08/15/java%E5%9F%BA%E7%A1%80%E7%AF%873%20%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%20%E6%AD%BB%E9%94%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础篇3 线程进程 死锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-03 17:44:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> 关于主题</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://differencer.oss-cn-beijing.aliyuncs.com/img/cover(1).jpg.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="tのblog"><span class="site-name">tのblog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> 关于主题</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础篇3 线程进程 死锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-15T15:28:35.000Z" title="发表于 2022-08-15 23:28:35">2022-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-03T09:44:01.686Z" title="更新于 2023-04-03 17:44:01">2023-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础篇3 线程进程 死锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a><strong>线程和进程</strong></h3><p><strong>进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</strong></p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，⽽ main 函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p>
<p>线程 但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。</p>
<h4 id="请简要描述线程与进程的关系-区别及优缺点"><a href="#请简要描述线程与进程的关系-区别及优缺点" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点"></a>请简要描述线程与进程的关系,区别及优缺点</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/image-20230329233406321.png" alt="image-20230329233406321" style="zoom:50%;" /></p>
<p>⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的元空间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈。</p>
<p>总结 ：线程 是 进程 划分成的更⼩的运⾏单位。线程和进程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互影响。线程执⾏开销⼩，但不利于资源的管理和保护；⽽进程正相反</p>
<h5 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h5><p>程序计数器主要有下⾯两个作⽤：</p>
<ol>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从⽽<strong>实现代码的流程控制</strong>，如：顺序执⾏、选择、循环、异常处理。</p>
</li>
<li><p>在<strong>多线程</strong>的情况下，程序计数器⽤于<strong>记录当前线程执⾏的位置</strong>，从⽽当线程被<strong>切换</strong>回来的时候能够知道该线程上次运⾏到哪⼉了。</p>
</li>
</ol>
<p>需要注意的是，<strong>如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的是 Java 代码时程序计数器记录的才是下⼀条指令的地址。</strong></p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执⾏位置</strong>。</p>
<p>XXX为什么时私有的？</p>
<ul>
<li>为了运行时不被其他线程干扰</li>
</ul>
<h5 id="⼀句话简单了解堆和⽅法区"><a href="#⼀句话简单了解堆和⽅法区" class="headerlink" title="⼀句话简单了解堆和⽅法区"></a>⼀句话简单了解堆和⽅法区</h5><p>堆和⽅法区是所有线程共享的资源，其中堆是进程中最⼤的⼀块内存，主要⽤于存放新创建的对象 (所有对象都在这⾥分配内存)，⽅法区主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h5 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h5><p>关键点 再单个时间点是否能同时</p>
<p>并发（<strong>Concurrent</strong>）： 同⼀时间段，多个任务都在执⾏ (单位时间内不⼀定同时执⾏)；（主要指CPU线程之间轮换）<br>并⾏（<strong>Parallel</strong>）：同一时间点，多个任务同时执⾏ （多个线程同时工作，不用轮换 多核CPU）。</p>
<h5 id="为什么要使⽤多线程呢"><a href="#为什么要使⽤多线程呢" class="headerlink" title="为什么要使⽤多线程呢?"></a>为什么要使⽤多线程呢?</h5><p>从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。另外，多核 CPU 时代意味着多个线程可以同时运⾏，这减少了线程上下⽂切换的开销。<br>从当代互联⽹发展趋势来说： 现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能</p>
<p>再深⼊到计算机底层来探讨：</p>
<p><strong>单核时代：</strong> 在单核时代多线程主要是为了提⾼ CPU 和 IO 设备的综合利⽤率。举个例⼦：当只有⼀个线程的时候会导致 CPU 计算时，IO 设备空闲；进⾏ IO 操作时，CPU 空闲。我们可以简单地说这两者的利⽤率⽬前都是 50%左右。但是当有两个线程的时候就不⼀样了，当⼀个线程执⾏ CPU 计算时，另外⼀个线程可以进⾏ IO 操作，这样两个的利⽤率就可以在理想情况下达到 100%了。</p>
<p><strong>多核时代</strong> 多核时代多线程主要是为了提⾼ CPU 利⽤率。举个例⼦：假如我们要计算⼀个复杂的任务，我们只⽤⼀个线程的话，CPU 只会⼀个 CPU 核⼼被利⽤到，⽽创建多个线程就可以让多个 CPU 核⼼被利⽤到，这样就提⾼了 CPU 的利⽤率。</p>
<p>多线程常见问题</p>
<p>并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：<strong>内存泄漏</strong>、<strong>上下⽂切换</strong>、<strong>死锁</strong> 。</p>
<h5 id="Q-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#Q-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="Q: 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>Q: 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h5><p>程序是含有指令和数据的文件，被存储在磁盘或其他数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的⼀次执⾏过程，是<strong>系统运⾏程序的基本单位</strong>,系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。</p>
<p>线程是进程划分成的更⼩的运⾏单位,线程是处理器任务调度和执行的基本单位。线程和进程最⼤的不同在于基本上各<strong>进程是独⽴的</strong>，⽽各<strong>线程则不⼀定</strong>，因为同⼀进程中的线程极有可能会相互影响。</p>
<h4 id="Q-java线程的状态状态"><a href="#Q-java线程的状态状态" class="headerlink" title="Q: java线程的状态状态"></a>Q: java线程的状态状态</h4><p>一种是将其分为6种一种是分为5种</p>
<h6 id="6种-主要是从java代码的角度来进行划分。"><a href="#6种-主要是从java代码的角度来进行划分。" class="headerlink" title="6种(主要是从java代码的角度来进行划分。)"></a>6种(主要是从java代码的角度来进行划分。)</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/22a2f59cc4ac491eac3cc4e6a6dbaa52.png" alt="img" style="zoom:33%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/6a02adfdfb96436da9273a899100d6d3.png" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<ol>
<li><p>新建状态(NEW) ：</p>
<blockquote>
<p>使用new关键字创建一个thread对象，刚刚创建出的这个线程就处于新建状态。在这个状态的线程没有与操作系真正的线程产生关联，仅仅是一个java对象。</p>
</blockquote>
</li>
<li><p>可运行(RUNABLE)：</p>
<blockquote>
<p>正在进行运行的线程，只有处于可运行状态的线程才会得到cpu资源。</p>
</blockquote>
</li>
<li><p>阻塞(BLOCKED) ：</p>
<blockquote>
<p>在可运行阶段争抢锁失败的线程就会从可运行—-&gt;阻塞</p>
</blockquote>
</li>
<li><p>等待(WAITING) ：</p>
<blockquote>
<p>可运行状态争抢锁成功，但是资源不满足，主动<strong>放弃锁</strong>（调用wait()方法）。条件满足后再恢复可运行状态（调用notiy()方法)</p>
</blockquote>
</li>
<li><p>有时限等待(TIMED WAITING)：</p>
<blockquote>
<p>类似于等待，不过区别在于有一个等待的时间，到达等待时间后或者调用notiy()，都能恢复为可运行状态。</p>
<p>有两种方式可以进入有时限等待：wait(Long)和sleep(Long)</p>
</blockquote>
</li>
<li><p>终结 (TERMINATED)</p>
<blockquote>
<p>代码全部执行完毕后，会进入到终结状态，释放所有的资源。</p>
</blockquote>
</li>
</ol>
<h6 id="5种-：划分依据：从操作系统层面划分"><a href="#5种-：划分依据：从操作系统层面划分" class="headerlink" title="5种 ：划分依据：从操作系统层面划分"></a>5种 ：划分依据：从操作系统层面划分</h6><p>划分依据：从操作系统层面划分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/1823d172fd074482a65b66484569cedd.png" alt="img" style="zoom:50%;" /></p>
<ol>
<li><p>新建 </p>
<blockquote>
<p>类似于六种，刚刚创建出的这个线程就处于新建状态。</p>
</blockquote>
</li>
<li><p>就绪</p>
<blockquote>
<p>线程分到CPU时间运行代码，但是还没有运行。 </p>
</blockquote>
</li>
<li><p>运行</p>
<blockquote>
<p>线程分到CPU时间运行代码，并且正在运行。</p>
</blockquote>
</li>
<li><p>阻塞</p>
<blockquote>
<p>线程暂时没有分到时间运行代码，就会进入阻塞状态，包括以下四种情况：</p>
<ul>
<li><p>a. IO阻塞：不需要cpu资源（磁盘读写，网络读写）</p>
</li>
<li><p>b. BLOCKED</p>
</li>
<li><p>c. WAITING</p>
</li>
<li><p>d. TIMED_WAITING</p>
</li>
</ul>
</blockquote>
</li>
<li><p>终结</p>
<blockquote>
<p>类似于代码全部执行完毕后，会进入到终结状态，释放所有的资源。</p>
</blockquote>
</li>
</ol>
<h5 id="什么是上下⽂切换"><a href="#什么是上下⽂切换" class="headerlink" title="什么是上下⽂切换?"></a>什么是上下⽂切换?</h5><p>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并<strong>轮转</strong>的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。</p>
<p>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换。</p>
<p>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</p>
<h4 id="Q-什么是线程死锁-如何避免死锁"><a href="#Q-什么是线程死锁-如何避免死锁" class="headerlink" title="Q: 什么是线程死锁?如何避免死锁?"></a>Q: 什么是线程死锁?如何避免死锁?</h4><h5 id="死锁面试题（什么是死锁，产生死锁的原因及必要条件）"><a href="#死锁面试题（什么是死锁，产生死锁的原因及必要条件）" class="headerlink" title="死锁面试题（什么是死锁，产生死锁的原因及必要条件）"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hd12370/article/details/82814348?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-82814348-blog-126295081.235%5Ev27%5Epc_relevant_default_base1&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-82814348-blog-126295081.235%5Ev27%5Epc_relevant_default_base1&amp;utm_relevant_index=1">死锁面试题（什么是死锁，产生死锁的原因及必要条件）</a></h5><p>线程死锁描述的是这样⼀种情况：</p>
<p>简单来说就是等待一个不可能被释放的锁，多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/image-20230330091752815.png" alt="image-20230330091752815" style="zoom:33%;" /></p>
<p>以上这个情况（上图）满足死锁产生的四个必要条件</p>
<h5 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h5><ol>
<li><strong>互斥条件</strong>：该资源任意⼀个时刻只由⼀个线程占⽤。</li>
<li><strong>请求与保持条件</strong>：⼀个进程因请求资源⽽阻塞时，<strong>对已获得的资源保持不放</strong>。 </li>
<li><strong>不剥夺条件:</strong>线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰<strong>使⽤完毕后才释放资源</strong>。</li>
<li><strong>循环等待条件:</strong>若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</li>
</ol>
<p>避免死锁的就是把上述必要条件破坏的过程</p>
<ol>
<li><p><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
</li>
<li><p><strong>破坏请求与保持条件</strong> ：⼀次性申请所有的资源。（其实不太容易 ）</p>
</li>
<li><p><strong>破坏不剥夺条件</strong> ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。（有点像事务）</p>
</li>
<li><p><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某⼀顺序申请资源（如银行家算法），释放资源则反序释放。破坏循环等待条件。</p>
</li>
</ol>
<ul>
<li>就我们能做的就是：<strong>1、以确定的顺序获得锁（银行家算法）</strong>（第四点）2、<strong>超时放弃</strong>（boolean tryLock 设置等待时间）因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁 （第三点）</li>
</ul>
<h5 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h5><ol>
<li>首先为每个进程和每个资源指定一个唯一的号码；</li>
<li>然后建立资源分配表和进程等待表。</li>
</ol>
<h5 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁:"></a>解除死锁:</h5><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
<p>1、Jstack命令</p>
<p>jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于<strong>生成java虚拟机当前时刻的线程快照</strong>。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，<strong>生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等</strong>。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p>
<p>2、JConsole工具</p>
<p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。</p>
<p>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</p>
<ul>
<li>两者最主要的区别在于： sleep() ⽅法没有释放锁，⽽ wait() ⽅法释放了锁 。</li>
<li>两者都可以暂停线程的执⾏。<ul>
<li>wait() 通常被⽤于线程间交互/通信， sleep() 通常被⽤于暂停执⾏。</li>
<li>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或<br>者 notifyAll() ⽅法。 sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(long<br>timeout) 超时后线程会⾃动苏醒。</li>
</ul>
</li>
</ul>
<p>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法？</p>
<p>调⽤ start() ⽅法⽅可启动线程并使线程进⼊就绪状态，直接执⾏ run() ⽅法的话不会以多线程的⽅式执⾏。</p>
<ul>
<li><p>直接使用<code>run()</code>会把 run()⽅法当成⼀个 main 线程下的<strong>普通⽅法</strong>去执⾏，并不会在某个线程中执⾏它，所以这并不是多线</p>
<p>程⼯作。</p>
</li>
<li><p>而，new ⼀个 Thread，线程进⼊了新建状态。调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。</p>
</li>
</ul>
<h4 id="⾃⼰对于-synchronized-关键字的了解"><a href="#⾃⼰对于-synchronized-关键字的了解" class="headerlink" title="⾃⼰对于 synchronized 关键字的了解"></a>⾃⼰对于 synchronized 关键字的了解</h4><p>synchronized 关键字解决的是多个线程之间访问资源的同步性， synchronized 关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p>
<p>另外，在 Java 早期版本中， synchronized 属于 <strong>重量级锁</strong>，效率低下。</p>
<p>监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成，⽽操作系统实现线程之间的切换时需要从⽤户态转换到内核态，这个状态之间的转换需要相对⽐较⻓的时间，时间成本相对较⾼。</p>
<p>是在 Java 6 之后 Java 官⽅对从 JVM 层⾯对 synchronized ᫾⼤优化，所以现在的synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引⼊了⼤量的优化，如⾃旋锁、适应性⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p> synchronized 关键字使用：</p>
<p>synchronized 关键字最主要的三种使⽤⽅式：</p>
<p>1.修饰实例⽅法</p>
<p>2.修饰静态⽅法 </p>
<p>3.修饰代码块（实例方法中的代码块，静待代码块）</p>
<p>总结</p>
<ul>
<li>synchronized( .class) 表示进⼊同步代码前要获得 当前 class 的锁，synchronized 关键字加到 static 静态⽅法和synchronized(class) 代码块上都是是给 Class类上锁。上一份代码当锁对象是<code>CodeBlock</code>的实例对象时并发度更大一些，因为当锁对象是实例对象的时候，只有实例对象内部是不能够并发的，实例之间是可以并发的。但是当锁对象是<code>CodeBlock.class</code>的时候，实例对象之间时不能够并发的，因为这个时候的锁对象是一个类。</li>
<li><p>synchronized 关键字加到实例⽅法上是给对象实例上锁。</p>
</li>
<li><p>尽量不要使⽤ synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</p>
</li>
</ul>
<p>如：</p>
<h6 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a><strong>双重校验锁实现对象单例（线程安全）</strong></h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，需要注意 uniqueInstance 采⽤ volatile 关键字（防止指令重排）修饰也是很有必要。 </p>
<p><strong>volatile是Java虚拟机提供的轻量级同步机制</strong></p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排（保证有序性）</li>
</ul>
<p>因为 这里面uniqueInstance = new Singleton(); 这段代码其实是分为三步执⾏：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ getUniqueInstance () 后发现 uniqueInstance 不为空，因此返回uniqueInstance ，但此时 uniqueInstance 还未被初始化。</p>
<h5 id="构造⽅法可以使⽤-synchronized-关键字修饰么？"><a href="#构造⽅法可以使⽤-synchronized-关键字修饰么？" class="headerlink" title="构造⽅法可以使⽤ synchronized 关键字修饰么？"></a>构造⽅法可以使⽤ synchronized 关键字修饰么？</h5><p>先说结论：构造⽅法不能使⽤ synchronized 关键字修饰。<br><strong>构造⽅法本身就属于线程安全的</strong>，不存在同步的构造⽅法⼀说。</p>
<h5 id="Synchronized关键字底层"><a href="#Synchronized关键字底层" class="headerlink" title="Synchronized关键字底层"></a>Synchronized关键字底层</h5><p>synchronized 同步语句块</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized 代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了⼀个 ObjectMonitor 对象。另外， wait/notify 等⽅法也依赖于 monitor 对象，这就是为什么只有在同步的块或者⽅法中才能调⽤ wait/notify 等⽅法，否则会抛出 java.lang.IllegalMonitorStateException 的异常的原因。</p>
</blockquote>
<p>当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。</p>
<p>在执⾏ monitorenter 时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。<br>在执⾏ monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为⽌。</p>
<h5 id="锁对象的建议"><a href="#锁对象的建议" class="headerlink" title="锁对象的建议"></a>锁对象的建议</h5><p>在前面的代码当中我们分别使用了实例对象和类的class对象作为锁对象，事实上你可以使用任何对象作为锁对象，但是<strong>不推荐使用字符串和基本类型的包装类作为锁对象</strong>，这是因为字符串对象和基本类型的包装对象会有缓存的问题。字符串有字符串常量池，整数有小整数池。因此在使用这些对象的时候他们可能最终都指向同一个对象，因为指向的都是同一个对象，线程获得锁对象的难度就会增加，程序的并发度就会降低。</p>
<p>synchronized  <strong>修饰⽅法的的情况</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo2</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"synchronized ⽅法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法。JVM 通过该ACC_SYNCHRONIZED 访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤</p>
<p>总结：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。
<span class="token keyword">synchronized</span> 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法。不过两者的本质都是对对象监视器 monitor 的获取。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p> 为什么要弄⼀个 CPU ⾼速缓存(CPU cache)呢？</p>
<p>类⽐我们开发⽹站后台系统使⽤的缓存（⽐如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 <strong>CPU 处理速度和内存处理速度不对等</strong>的问题。<br>我们甚⾄可以把 内存可以看作外存的⾼速缓存，程序运⾏的时候我们把外存的数据复制到内存，由于内存的处理速度远远⾼于外存，这样提⾼了处理速度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/image-20230330102034896.png" alt="image-20230330102034896" style="zoom:33%;" /></p>
<p>先复制⼀份数据到 CPU Cache 中，当 CPU 需要⽤到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不⼀致性的问题 ！⽐如我执⾏⼀个 i++操作的话，如果两个线程同时执⾏的话，假设两个线程从 CPUCache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，⽽正确结果应该是 i=3。CPU 为了解决内存缓存不⼀致性问题可以通过制定缓存⼀致协议或者其他⼿段来解决</p>
<p>讲⼀下 JMM(Java 内存模型)</p>
<p>在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致.(可以理解为 JIT 对热点数据的优化)</p>
<p>解决，对相应的变量上怎加voletile关键字，，这就指示 JVM，这个变量是共享且不稳定的，每次使⽤它都到共享内存中进⾏读取</p>
<p>所以记住：， volatile 关键字 除了防⽌ JVM 的指令重排（如双检索单例模式，在静态成员变量（单例）前面要加 volatile关键字，避免这个变量创建过程中的指令重排） ，还有⼀个重要的作⽤就是保证变量的可⻅性（避免JIT对热点代码进行优化时将变量放到CPU缓存上导致与内存中的变量值不一致）。</p>
<h4 id="Q-ThreadLocal"><a href="#Q-ThreadLocal" class="headerlink" title="Q: ThreadLocal"></a>Q: ThreadLocal</h4><p>详细见引用类型与ThreadLocal这篇文章</p>
<ul>
<li>线程并发； </li>
<li>传递数据； 通过ThreadLoacal 在同一线程，不同组件中传递公共变量（有点像javaweb）</li>
<li>线程隔离</li>
</ul>
<p>通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的专属本地变量该如何解决呢？ JDK 中提供的 ThreadLocal 类正是为了解决这样的问题。ThreadLocal 类主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成存放数据的盒⼦，盒⼦中可以存储每个线程的私有数据。</p>
<p>如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。他们可以使⽤ get 和 set ⽅法来获取默认值或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。</p>
<p>底层：</p>
<p>从 Thread 类源代码⼊⼿。</p>
<p> <strong>Thread 类</strong>中有 名为 threadLocals 和 ⼀个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量</p>
<p>我们可以把ThreadLocalMap 理解为 ThreadLocal 类实现的定制化的 HashMap 。。默认情况下这两个变量都是 null，只有当前线程调⽤ ThreadLocal 类的 set 或 get ⽅法时才创建它们，实际上调⽤这两个⽅法的时候，我们调⽤的是 ThreadLocalMap 类对应的 get() 、 set() ⽅法</p>
<p>通过上⾯这些内容，我们⾜以通过猜测得出结论：最终的变量是放在了当前线程的ThreadLocalMap 中，并不是存在 ThreadLocal 上， ThreadLocal 可以理解为只是 ThreadLocalMap 的封装，传递了变量值。 ThrealLocal 类中可以通过 Thread.currentThread()<br>获取到当前线程对象后，直接通过 getMap(Thread t) 可以访问到该线程的 ThreadLocalMap 对象。</p>
<p>ThreadLocal 内部维护的是⼀个类似 Map 的 ThreadLocalMap 数据结构， <strong>key 为当前对象的 Thread 对象</strong>，值为 Object 对象。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a><a class="post-meta__tags" href="/tags/%E6%AD%BB%E9%94%81/">死锁</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/02/HashMap/" title="HashMap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HashMap</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/11/MySQL%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%861/" title="MySQL基本知识1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/u=1128666124,3756061506&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL基本知识1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/" title="操作系统基础知识复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-03</div><div class="title">操作系统基础知识复习</div></div></a></div><div><a href="/2023/03/31/AQS%E4%B8%8EReentrantLock/" title="AQS与ReentrantLock"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-31</div><div class="title">AQS与ReentrantLock</div></div></a></div><div><a href="/2023/03/23/Java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8CThreadLocal/" title="Java四种引用类型以及ThreadLocal"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230604145047.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="title">Java四种引用类型以及ThreadLocal</div></div></a></div><div><a href="/2022/07/12/java-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/" title="java 线程状态"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">java 线程状态</div></div></a></div><div><a href="/2022/09/02/HashMap/" title="HashMap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">HashMap</div></div></a></div><div><a href="/2022/07/22/java%E5%9F%BA%E7%A1%80%E7%AF%871/" title="java 基础篇1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-22</div><div class="title">java 基础篇1</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">taotaozi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/differencer"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/differencer?type=blog" target="_blank" title="Github"><i class="fab fa-CSDN"></i></a><a class="social-icon" href="https://space.bilibili.com/20713910" target="_blank" title="Bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="/473439851" target="_blank" title="steam"><i class="fab fa-steam"></i></a><a class="social-icon" href="https://weibo.com/u/5856795355" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="mailto:1359114644@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">最近的新任务是 ： 努力啊</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">请简要描述线程与进程的关系,区别及优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="toc-text">程序计数器为什么是私有的?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%BC%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E2%BD%85%E6%B3%95%E5%8C%BA"><span class="toc-text">⼀句话简单了解堆和⽅法区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2"><span class="toc-text">为什么要使⽤多线程呢?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Q-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%82%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q: 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E7%8A%B6%E6%80%81"><span class="toc-text">Q: java线程的状态状态</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E7%A7%8D-%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BB%8Ejava%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86%E3%80%82"><span class="toc-text">6种(主要是从java代码的角度来进行划分。)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E7%A7%8D-%EF%BC%9A%E5%88%92%E5%88%86%E4%BE%9D%E6%8D%AE%EF%BC%9A%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E5%88%92%E5%88%86"><span class="toc-text">5种 ：划分依据：从操作系统层面划分</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E2%BD%82%E5%88%87%E6%8D%A2"><span class="toc-text">什么是上下⽂切换?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">Q: 什么是线程死锁?如何避免死锁?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-text">死锁面试题（什么是死锁，产生死锁的原因及必要条件）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">死锁产生的四个必要条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-text">检测死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="toc-text">解除死锁:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%BE%83%E2%BC%B0%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">⾃⼰对于 synchronized 关键字的了解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%8D%95%E4%BE%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">双重校验锁实现对象单例（线程安全）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BD%BF%E2%BD%A4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B9%88%EF%BC%9F"><span class="toc-text">构造⽅法可以使⽤ synchronized 关键字修饰么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%95%E5%B1%82"><span class="toc-text">Synchronized关键字底层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">锁对象的建议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-ThreadLocal"><span class="toc-text">Q: ThreadLocal</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/15/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%914-%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发4-认证授权模块开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230615083641.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发4-认证授权模块开发"/></a><div class="content"><a class="title" href="/2023/06/15/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%914-%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发4-认证授权模块开发">类MOOC系统开发4-认证授权模块开发</a><time datetime="2023-06-15T00:35:37.000Z" title="发表于 2023-06-15 08:35:37">2023-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/12/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%913-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发3-课程发布模块开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230612133618.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发3-课程发布模块开发"/></a><div class="content"><a class="title" href="/2023/06/12/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%913-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发3-课程发布模块开发">类MOOC系统开发3-课程发布模块开发</a><time datetime="2023-06-12T05:35:38.000Z" title="发表于 2023-06-12 13:35:38">2023-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%912-%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发2-媒资管理模块开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230601152807.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发2-媒资管理模块开发"/></a><div class="content"><a class="title" href="/2023/06/01/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%912-%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发2-媒资管理模块开发">类MOOC系统开发2-媒资管理模块开发</a><time datetime="2023-06-01T07:27:10.000Z" title="发表于 2023-06-01 15:27:10">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/25/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%911-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发1-内容管理模块开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230525224811.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类MOOC系统开发1-内容管理模块开发"/></a><div class="content"><a class="title" href="/2023/05/25/%E7%B1%BBMOOC%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%911-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/" title="类MOOC系统开发1-内容管理模块开发">类MOOC系统开发1-内容管理模块开发</a><time datetime="2023-05-25T14:46:56.000Z" title="发表于 2023-05-25 22:46:56">2023-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/22/%E7%AE%97%E6%B3%95_%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98/" title="算法:单调栈问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/20230522212237.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法:单调栈问题"/></a><div class="content"><a class="title" href="/2023/05/22/%E7%AE%97%E6%B3%95_%E5%8D%95%E8%B0%83%E6%A0%88%E9%97%AE%E9%A2%98/" title="算法:单调栈问题">算法:单调栈问题</a><time datetime="2023-05-22T13:20:06.000Z" title="发表于 2023-05-22 21:20:06">2023-05-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://differencer.oss-cn-beijing.aliyuncs.com/img/cover(1).jpg.webp')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By taotaozi</div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'differencer/giscus',
    'data-repo-id': 'R_kgDOJMrL1A',
    'data-category-id': 'DIC_kwDOJMrL1M4CVC1y',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>