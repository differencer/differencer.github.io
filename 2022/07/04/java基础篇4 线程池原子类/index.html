<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java基础篇4 线程池原子类 | tのblog</title><meta name="author" content="taotaozi"><meta name="copyright" content="taotaozi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程类的执行方式一、runnable的执行 , 作为thread的参数 public class MyRunnable implements Runnable &amp;#123;     @Override     public void run() &amp;#123;         &#x2F;&#x2F; 在这里定义可在线程中执行的代码     &amp;#125; &amp;#125;  MyRunnable myR">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础篇4 线程池原子类">
<meta property="og:url" content="https://differencer.github.io/2022/07/04/java%E5%9F%BA%E7%A1%80%E7%AF%874%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E5%AD%90%E7%B1%BB/index.html">
<meta property="og:site_name" content="tのblog">
<meta property="og:description" content="线程类的执行方式一、runnable的执行 , 作为thread的参数 public class MyRunnable implements Runnable &amp;#123;     @Override     public void run() &amp;#123;         &#x2F;&#x2F; 在这里定义可在线程中执行的代码     &amp;#125; &amp;#125;  MyRunnable myR">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://differencer.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-07-04T00:40:59.000Z">
<meta property="article:modified_time" content="2023-04-03T09:41:15.693Z">
<meta property="article:author" content="taotaozi">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://differencer.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://differencer.github.io/2022/07/04/java%E5%9F%BA%E7%A1%80%E7%AF%874%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E5%AD%90%E7%B1%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础篇4 线程池原子类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-03 17:41:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> 关于主题</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://differencer.oss-cn-beijing.aliyuncs.com/img/cover(1).jpg.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="tのblog"><span class="site-name">tのblog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> 关于主题</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础篇4 线程池原子类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-04T00:40:59.000Z" title="发表于 2022-07-04 08:40:59">2022-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-03T09:41:15.693Z" title="更新于 2023-04-03 17:41:15">2023-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础篇4 线程池原子类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="线程类的执行方式"><a href="#线程类的执行方式" class="headerlink" title="线程类的执行方式"></a>线程类的执行方式</h4><p>一、runnable的执行 , 作为thread的参数</p>
<pre class="line-numbers language-none"><code class="language-none">public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        &#x2F;&#x2F; 在这里定义可在线程中执行的代码
    &#125;
&#125;

MyRunnable myRunnable &#x3D; new MyRunnable();
Thread thread &#x3D; new Thread(myRunnable);
thread.start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>or</p>
<pre class="line-numbers language-none"><code class="language-none">Thread thread &#x3D; new Thread(new Runnable() &#123;
    @Override
    public void run() &#123;
        &#x2F;&#x2F; 在这里定义可在线程中执行的代码
    &#125;
&#125;);
thread.start();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>二、callable的执行，被ExecutorService执行or作为FeatureTask的参数</p>
<p>(后面看 底层，发现最终还是底层还是用execute(Runnable r)实现的 只不过这里的r是经过 FutureTask 封装过的Runnable </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 在这里定义可被调用的代码</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token class-name">MyCallable</span> myCallable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>myCallable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">T</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>or</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 在这里定义可被调用的代码</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">T</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>or<br>使用FeatureTask (用FutureTask 包装 callable 再将FutureTask 对象作为参数创建线程，开启，获取参数通过FutureTask 对象获取 )</p>
<p>Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。</p>
<p>其实FutureTask 又实现了Runnable接口, 所以线程接受的还是一个Runnable变量…..</p>
<pre class="line-numbers language-none"><code class="language-none">Callable&lt;Process&gt; task &#x3D; () -&gt; &#123;
   &#x2F;&#x2F; 执行异步任务
   Runtime runtime &#x3D; Runtime.getRuntime();
   Process process &#x3D; runtime.exec(&quot;&#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;qc-java-runtime&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;qc&#x2F;runtime&#x2F;shell.sh&quot;);
   return process;
&#125;;

&#x2F;&#x2F; 将Callable包装成FutureTask
FutureTask&lt;Process&gt; future &#x3D; new FutureTask&lt;&gt;(task);

&#x2F;&#x2F; 启动新线程来执行异步任务
new Thread(future).start();

&#x2F;&#x2F; 获取异步任务的结果
Process result &#x3D; future.get();
System.out.println(result);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实现 Runnable 接⼝和 Callable 接⼝的区别</p>
<ul>
<li>1、最大的区别，runnable没有返回值，而实现callable接口的任务线程能返回执行结果（调用结果时主线程会阻塞来等待执行获取结果）</li>
<li><p>2、callable接口实现类中的run方法允许异常向上抛出，可以在内部处理，try catch，但是runnable接口实现类中run方法的异常必须在内部处理，不能抛出;所以，如果任务不需要返回结果或抛出异常推荐使⽤ <strong>Runnable</strong> <strong>接⼝</strong>，这样代码看起来会更加简洁</p>
</li>
<li><p>3、callable和runnable都可以应用于executors(线程池)。而thread类只支持runnable</p>
<ul>
<li>⼯具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（ Executors.callable Runnable task ）或 Executors.callable Runnable task Object resule ）</li>
</ul>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><strong>线程池</strong></h3><p> <strong>为什么要⽤线程池？</strong></p>
<p>池化技术相⽐⼤家已经屡⻅不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应⽤。池化技术的思想主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。（避免每次重新建立对象，而直接保留这个对象复用）</p>
<p><strong>线程池</strong>提供了⼀种限制和管理资源（包括执⾏⼀个任务）。 每个<strong>线程池</strong>还维护⼀些基本统计信息，例如已完成任务的数量。</p>
<p>这⾥借⽤《Java 并发编程的艺术》提到的来说⼀下使⽤线程池的好处：</p>
<ul>
<li>降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。</li>
<li>提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降</li>
<li>低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。</li>
</ul>
<h3 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h3><p>是 Java5 之后引进的，通过 Executor 来启动线程比使用 Thread 的start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<p>Executor 框架不仅包括了<strong>线程池</strong>的管理，还提供了<strong>线程工厂</strong>、<strong>队列</strong>以及<strong>拒绝策略</strong>等，Executor 框架让并发编程变得更加简单。</p>
<h4 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a>Executor 框架结构</h4><p>1) 任务( Runnable / Callable )<br>    执行任务需要实现的 Runnable 接口 或 Callable 接口。 Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</p>
<p>2)  任务的执行( Executor )</p>
<p>  如下图所示，包括任务执行机制的核心接口 Executor ，以及继承自 Executor 接口的ExecutorService 接口。 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/image-20230331093320424.png" alt="image-20230331093320424" style="zoom:50%;" /></p>
<p>  这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</p>
<p>3) 异步计算的结果( Future ) （当需要获取线程执行结果时）</p>
<p>   Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。<br>   当我们把 Runnable 接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）</p>
<h4 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a><strong>Executor</strong> <strong>框架的使用示意图</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/image-20230331093643850.png" alt="image-20230331093643850" style="zoom:50%;" /></p>
<ol>
<li>主线程首先要创建实现 <code>Runnable</code> 或者<code>Callable</code> 接口的任务对象。</li>
<li>把创建完成的实现 <code>Runnable</code> 接口的 对象直接交给<code>execute(Runnable r)</code>，或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>submit(Runnable r)  or  submit(Callable c)</code>。</li>
<li>如果执行 <code>ExecutorService.submit（…）</code> ，<code>ExecutorService</code> 将返回一个实现 <code>Future</code> 接口的对象<code>submit()</code> 会返回一个<code>FutureTask</code> 对象）。由于 <code>FutureTask</code> 实现了<code>Runnable</code>，我们也可以创建<code>FutureTask</code>，然后直接交给 <code>ExecutorService</code>执行。</li>
<li>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行<code>FutureTask.cancel（boolean mayInterruptIfRunning）</code> 来取消此任务的执行。</li>
</ol>
<p>执行 execute() 方法和 submit() 方法的区别</p>
<blockquote>
<ol>
<li><p>execute() (只能接收实现了Runable接口的实现类)</p>
<p>该⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；</p>
</li>
<li><p>submit()  （可以接收Callable、Runnable两种类型的参数）</p>
<p>该⽅法⽤于提交需要返回值的任务。</p>
<p>线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get long timeout TimeUnitunit ⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏完</p>
</li>
<li><p>即使用了<code>submit()</code>底层 <code>ExecutorService</code>  还是用的<code>execute</code></p>
</li>
</ol>
<p>异常</p>
<p>execute会直接抛出任务执行时的异常，可以用try、catch来捕获，和普通线程的处理方式完全一致</p>
<p>submit会吃掉异常，可通过Future的get方法将任务执行时的异常重新抛出。</p>
</blockquote>
<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p>线程池的创建⽅式总共包含以下 <strong>7 种</strong>（其中 6 种是通过 Executors （工具类）创建的， 1 种是通过ThreadPoolExecutor 创建的, 其实前四个底层都是ThreadPoolExecutor）</p>
<ol>
<li>Executors.newFixedThreadPool：创建⼀个固定⼤⼩的线程池，可控制并发的线程数，超出的线程会在队列中等待；<ul>
<li>允许请求的队列⻓度为Integer.MAX_VALUE</li>
</ul>
</li>
<li>Executors.newCachedThreadPool：创建⼀个可缓存的线程池，若线程数超过处理所需，缓存⼀段时间后会回收，若线程数不够，则新建线程；<ul>
<li>允许创建的线程数量为 Integer.MAX_VALUE</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执⾏顺序；<ul>
<li>允许请求的队列⻓度为Integer.MAX_VALUE </li>
</ul>
</li>
<li>Executors.newScheduledThreadPool：创建⼀个可以执⾏延迟任务的线程池；<ul>
<li>允许创建的线程数量为Integer.MAX_VALUE </li>
</ul>
</li>
<li>Executors.newSingleThreadScheduledExecutor：创建⼀个单线程的可以执⾏延迟任务的线程池；</li>
<li>Executors.newWorkStealingPool：创建⼀个抢占式执⾏的线程池（任务执⾏顺序不确定）【JDK1.8 添加】。</li>
<li>ThreadPoolExecutor：最原始的创建线程池的⽅式，它包含了 7 个参数可供设置，后⾯会详细讲。</li>
</ol>
<p>《阿⾥巴巴 Java 开发⼿册》中强制线程池不允许使⽤ Executors 去创建，⽽是通过ThreadPoolExecutor 的⽅式，这样的处理⽅式让写的同学更加明确线程池的运⾏规则，规避资源耗尽的⻛险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<p><strong>FixedThreadPool</strong> <strong>和</strong> <strong>SingleThreadExecutor</strong> ： 允许请求的队列⻓度为Integer.MAX_VALUE ，可能堆积⼤量的请求，从⽽导致 OOM。</p>
<p><strong>CachedThreadPool</strong> <strong>和</strong> <strong>ScheduledThreadPool</strong> ： 允许创建的线程数量为Integer.MAX_VALUE ，可能会创建⼤量线程，从⽽导致 OOM。</p>
</blockquote>
<h4 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>corePoolSize ：线程池中核心线程数的最大值</li>
<li>maximumPoolSize ：线程池中能拥有最多线程数</li>
<li>workQueue：用于缓存任务的阻塞队列</li>
</ul>
<p>当调用线程池execute() 方法添加一个任务时，线程池会做如下判断：</p>
<blockquote>
<ul>
<li>如果有空闲线程，则直接执行该任务；</li>
<li>如果没有空闲线程，且当前运行的线程数少于corePoolSize，则创建新的线程执行该任务；</li>
<li>如果没有空闲线程，且当前的线程数等于corePoolSize，同时阻塞队列未满，则将任务入队列，而不添加新的线程；</li>
<li>如果没有空闲线程，且阻塞队列已满，同时池中的线程数小于maximumPoolSize ，则创建新的线程执行任务；</li>
<li>如果没有空闲线程，且阻塞队列已满，同时池中的线程数等于maximumPoolSize ，则根据构造函数中的 handler 指定的策略来拒绝新的任务。</li>
</ul>
</blockquote>
<p>KeepAliveTime：</p>
<blockquote>
<ul>
<li>keepAliveTime ：表示空闲线程的存活时间</li>
<li>TimeUnit unit ：表示keepAliveTime的单位</li>
</ul>
<p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
</blockquote>
<p>workQueue 任务队列：</p>
<ul>
<li>workQueue ：它决定了缓存任务的排队策略</li>
</ul>
<p>ThreadPoolExecutor线程池推荐了三种等待队列，它们是：SynchronousQueue 、LinkedBlockingQueue和 ArrayBlockingQueue。</p>
<blockquote>
<p><strong>1）有界队列：</strong></p>
<p>SynchronousQueue ：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于 阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。<br>ArrayBlockingQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p>
<p><strong>2）无界队列：</strong></p>
<p>LinkedBlockingQueue：基于链表结构的无界阻塞队列，它可以指定容量也可以不指定容量（实际上任何无限容量的队列/栈都是有容量的，这个容量就是Integer.MAX_VALUE）<br>PriorityBlockingQueue：是一个按照优先级进行内部元素排序的无界阻塞队列。队列中的元素必须实现 Comparable 接口，这样才能通过实现compareTo()方法进行排序。优先级最高的元素将始终排在队列的头部；PriorityBlockingQueue 不会保证优先级一样的元素的排序。<br>注意：keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。</p>
</blockquote>
<p>threadFactory：</p>
<ul>
<li><p>threadFactory ：指定创建线程的工厂。（可以不指定） 一般使用Executors 工具类里面指定的工厂</p>
</li>
<li><blockquote>
<p>如果不指定线程工厂时，ThreadPoolExecutor 会使用ThreadPoolExecutor.defaultThreadFactory 创建线程。默认工厂创建的线程：同属于相同的线程组，具有同为 Thread.NORM_PRIORITY 的优先级，以及名为 “pool-XXX-thread-” 的线程名（XXX为创建线程时顺序序号），且创建的线程都是非守护进程。</p>
</blockquote>
</li>
</ul>
<p>handler 拒绝策略：</p>
<ul>
<li><p>handler ：表示当 workQueue 已满，且池中的线程数达到 maximumPoolSize 时，线程池拒绝添加新任务时采取的策略。（可以不指定）</p>
</li>
<li><p>| 策略                                     | BB                                                           |<br>| ———————————————————— | —————————————————————————————— |<br>| ThreadPoolExecutor.AbortPolicy()         | 来拒绝新任务的处理。抛出RejectedExecutionException异常。默认策略 |<br>| ThreadPoolExecutor.CallerRunsPolicy()    | 由向线程池提交任务的线程来执行该任务，当最⼤池被填满时，此策略为我们提供可伸缩队列。 |<br>| ThreadPoolExecutor.DiscardPolicy()       | 不处理新任务，直接丢弃掉。                                   |<br>| ThreadPoolExecutor.DiscardOldestPolicy() | 此策略将丢弃最早的队列中那个未处理的任务请求                 |</p>
<p>最科学的的还是 AbortPolicy 提供的处理方式：抛出异常，由开发人员进行处理。</p>
</li>
</ul>
<h3 id="Atomic-原⼦类"><a href="#Atomic-原⼦类" class="headerlink" title="Atomic 原⼦类"></a><strong>Atomic</strong> <strong>原⼦类</strong></h3><p>Atomic 翻译成中⽂是原⼦的意思。在化学上，我们知道原⼦是构成⼀般物质的最⼩单位，在化学反应中是不可分割的。在我们这⾥ Atomic 是指⼀个操作是不可中断的。即使是在多个线程⼀起执⾏的时候，⼀个操作⼀旦开始，就不会被其他线程⼲扰。</p>
<p>并发包 java.util.concurrent 的原⼦类都存放在 java.util.concurrent.atomic中</p>
<p>JUC 包中的原⼦类（4类）</p>
<h5 id="原子基本类型"><a href="#原子基本类型" class="headerlink" title="原子基本类型"></a><strong>原子基本类型</strong></h5><p>使⽤原⼦的⽅式更新基本类型</p>
<ul>
<li>AtomicInteger ：整形原⼦类</li>
<li>AtomicLong ：⻓整型原⼦类</li>
<li>AtomicBoolean ：布尔型原⼦类</li>
</ul>
<h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a><strong>数组类型</strong></h5><p>使⽤原⼦的⽅式更新数组⾥的某个元素</p>
<ul>
<li>AtomicIntegerArray ：整形数组原⼦类</li>
<li>AtomicLongArray ：⻓整形数组原⼦类</li>
<li>AtomicReferenceArray ：引⽤类型数组原⼦类</li>
</ul>
<h5 id="引⽤类型"><a href="#引⽤类型" class="headerlink" title="引⽤类型"></a><strong>引⽤类型</strong></h5><ul>
<li>AtomicReference ：引⽤类型原⼦类</li>
<li>AtomicStampedReference ：原⼦更新带有版本号的引⽤类型。该类将整数值与引⽤关联起来，可⽤于解决原⼦的更新数据和数据的版本号，可以解决使⽤ CAS 进⾏原⼦更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原⼦更新带有标记位的引⽤类型</li>
</ul>
<h5 id="对象的属性修改类型"><a href="#对象的属性修改类型" class="headerlink" title="对象的属性修改类型"></a><strong>对象的属性修改类型</strong></h5><ul>
<li>AtomicIntegerFieldUpdater ：原⼦更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater ：原⼦更新⻓整形字段的更新器</li>
<li>AtomicReferenceFieldUpdater ：原⼦更新引⽤类型字段的更新器</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><strong>AQS</strong></h3><p>关于AQS 具体看看 我的 <strong>AQS 与ReentrantLock</strong>这篇博客</p>
<p>​        AQS 的全称为（ AbstractQueuedSynchronizer ），这个类在 java.util.concurrent.locks 包下⾯。</p>
<p>   AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个<strong>共享资源状态</strong>（ Volatile Int State ）和一个先进先出（ FIFO ）的<strong>线程等待队列</strong>来实现一个多线程访问共享资源的同步框架。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://differencer.oss-cn-beijing.aliyuncs.com/img/67a2b73dfd6642f39efe2a8986bbca38.png" alt="在这里插入图片描述" style="zoom: 80%;" /></p>
<p>状态信息通过 protected 类型的 getState ， setState ， compareAndSetState 进行操作</p>
<p><strong>AQS</strong> <strong>定义两种资源共享方式</strong></p>
<p>1)<strong>Exclusive</strong>（独占）</p>
<p>只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p>
<ol>
<li><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p>
</li>
<li><p>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</p>
</li>
</ol>
<p>了解一下 ReentrantLock 中相关知识：</p>
<p>ReentrantLock 实现了 Lock 接口，Lock 接口中定义了 lock 与 unlock 相关操作，并且还存在newCondition 方法，表示生成一个条件。</p>
<p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** Synchronizer providing all implementation mechanics */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 默认非公平锁</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2) <strong>Share</strong>（共享）：多个线程可同时执⾏，如</p>
<p>CountDownLatch 、 Semaphore 、 CountDownLatch 、 CyclicBarrier 、 ReadWriteLock 我们都会在后⾯讲到</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某⼀资源进⾏读</p>
<p>不同的⾃定义同步器争⽤共享资源的⽅式也不同。⾃定义同步器在实现时只需要实现共享资源state 的获取与释放⽅式即可，⾄于具体线程等待队列的维护（如获取资源失败⼊队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<p> <strong>AQS</strong> <strong>底层使⽤了模板⽅法模式</strong></p>
<p>同步器的设计是基于模板⽅法模式的，如果需要⾃定义同步器⼀般的⽅式是这样（模板⽅法模式很经典的⼀个应⽤）</p>
<ol>
<li><p>使⽤者继承 AbstractQueuedSynchronizer 并重写指定的⽅法。（这些重写⽅法很简单，⽆⾮是对于共享资源 state 的获取和释放）</p>
</li>
<li><p>将 AQS 组合在⾃定义同步组件的实现中，并调⽤其模板⽅法，⽽这些模板⽅法会调⽤使⽤者重写的⽅法。</p>
</li>
</ol>
<p><strong>AQS</strong> <strong>使⽤了模板⽅法模式，⾃定义同步器时需要重写下⾯⼏个</strong> <strong>AQS</strong> <strong>提供的模板⽅法：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//该线程是否正在独占资源。只有⽤到condition才需要去实现它。</span>
<span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占⽅式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占⽅式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享⽅式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可⽤资源；正数表示成功，且有剩余资源。</span>
<span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享⽅式。尝试释放资源，成功则返回true，失败则返回false。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认情况下，每个⽅法都抛出 UnsupportedOperationException 。 这些⽅法的实现必须是内部线程安全的，并且通常应该简短⽽不是阻塞。AQS 类中的其他⽅法都是 final ，所以⽆法被其他类使⽤，只有这⼏个⽅法可以被其他类使⽤</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调⽤tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程unlock()到 state=0（即释放锁）为⽌，其它线程才有机会获取该锁。当然，释放锁之前，A 线程⾃⼰是可以重复获取此锁的（state 会累加），这就是可重⼊的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个⼦线程去执⾏，state 也初始化为 N（注意 N 要与线程个数⼀致）。这 N 个⼦线程是并⾏执⾏的，每个⼦线程执⾏完后 countDown() ⼀次，state 会CAS(Compare and Swap)减 1。等到所有⼦线程都执⾏完后(即 state=0)，会 unpark()主调⽤线程，然后主调⽤线程就会从 await() 函数返回，继续后余动作。</p>
<p>⼀般来说，⾃定义同步器要么是独占⽅法，要么是共享⽅式，他们也只需实现 tryAcquire tryRelease 、 tryAcquireShared-tryReleaseShared 中的⼀种即可。但 AQS 也⽀持⾃定义同步器同时实现独占和共享两种⽅式，如 ReentrantReadWriteLock 。</p>
<p>推荐两篇 AQS 原理和相关源码分析的⽂章：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/06/JVM%E7%AC%94%E8%AE%B0-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" title="JVM笔记-JVM内存结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM笔记-JVM内存结构</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/22/java-%E5%9F%BA%E7%A1%80%E7%AF%87-String%E7%B1%BB/" title="java 基础篇 String类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java 基础篇 String类</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">taotaozi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/differencer"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/differencer?type=blog" target="_blank" title="Github"><i class="fab fa-CSDN"></i></a><a class="social-icon" href="https://space.bilibili.com/20713910" target="_blank" title="Bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="/473439851" target="_blank" title="steam"><i class="fab fa-steam"></i></a><a class="social-icon" href="https://weibo.com/u/5856795355" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="mailto:1359114644@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">最近的新任务是 ： 努力啊</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-text">线程类的执行方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor-%E6%A1%86%E6%9E%B6"><span class="toc-text">Executor 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor-%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Executor 框架结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">Executor 框架的使用示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">如何创建线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadPoolExecutor-%E7%B1%BB%E5%88%86%E6%9E%90"><span class="toc-text">ThreadPoolExecutor 类分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-%E5%8E%9F%E2%BC%A6%E7%B1%BB"><span class="toc-text">Atomic 原⼦类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">原子基本类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E2%BD%A4%E7%B1%BB%E5%9E%8B"><span class="toc-text">引⽤类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">对象的属性修改类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"> </span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/" title="操作系统基础知识复习">操作系统基础知识复习</a><time datetime="2023-04-03T09:23:14.000Z" title="发表于 2023-04-03 17:23:14">2023-04-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/03/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" title="TCP三次握手和四次挥手">TCP三次握手和四次挥手</a><time datetime="2023-04-03T08:27:07.000Z" title="发表于 2023-04-03 16:27:07">2023-04-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/02/JAVA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" title="JAVA对象的创建过程">JAVA对象的创建过程</a><time datetime="2023-04-02T12:10:05.000Z" title="发表于 2023-04-02 20:10:05">2023-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/31/AQS%E4%B8%8EReentrantLock/" title="AQS与ReentrantLock">AQS与ReentrantLock</a><time datetime="2023-03-31T03:46:08.000Z" title="发表于 2023-03-31 11:46:08">2023-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/27/leetcode-Hot100/" title="leetcode Hot100">leetcode Hot100</a><time datetime="2023-03-27T07:33:23.000Z" title="发表于 2023-03-27 15:33:23">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://differencer.oss-cn-beijing.aliyuncs.com/img/cover(1).jpg.webp')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By taotaozi</div><div class="footer_custom_text">世上最幸运的事就是喜欢上一个人</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'differencer/giscus',
    'data-repo-id': 'R_kgDOJMrL1A',
    'data-category-id': 'DIC_kwDOJMrL1M4CVC1y',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>